* [1. 基础知识](#1-基础知识)
  * [1.1 C++ 简介](#11-c-简介)
    * [1.1.1 C++ 的历史和发展](#111-c-的历史和发展)
      * [1.1.1.1 简介](#1111-简介)
      * [1.1.1.2 发展历程](#1112-发展历程)
    * [1.1.2 C++ 与 C 的区别](#112-c-与-c-的区别)
      * [1.1.2.1 语法差异](#1121-语法差异)
      * [1.1.2.2 功能差异](#1122-功能差异)
    * [1.1.3 C++ 的应用领域](#113-c-的应用领域)
      * [1.1.3.1 系统编程](#1131-系统编程)
      * [1.1.3.2 游戏开发](#1132-游戏开发)
      * [1.1.3.3 嵌入式系统](#1133-嵌入式系统)
  * [1.2 数据类型](#12-数据类型)
    * [1.2.1 基本数据类型](#121-基本数据类型)
      * [1.2.1.1 整型](#1211-整型)
      * [1.2.1.2 浮点型](#1212-浮点型)
      * [1.2.1.3 字符型](#1213-字符型)
    * [1.2.2 用户定义类型](#122-用户定义类型)
      * [1.2.2.1 枚举](#1221-枚举)
      * [1.2.2.2 结构体](#1222-结构体)
      * [1.2.2.3 联合体](#1223-联合体)
    * [1.2.3 类型转换](#123-类型转换)
      * [1.2.3.1 隐式转换](#1231-隐式转换)
      * [1.2.3.2 显式转换](#1232-显式转换)
  * [1.3 变量和常量](#13-变量和常量)
    * [1.3.1 变量的声明与定义](#131-变量的声明与定义)
      * [1.3.1.1 声明](#1311-声明)
      * [1.3.1.2 定义](#1312-定义)
      * [1.3.1.3 初始化](#1313-初始化)
    * [1.3.2 常量的定义与使用](#132-常量的定义与使用)
      * [1.3.2.1 常量的定义](#1321-常量的定义)
      * [1.3.2.2 常量的使用](#1322-常量的使用)
    * [1.3.3 作用域和生命周期](#133-作用域和生命周期)
      * [1.3.3.1 作用域](#1331-作用域)
      * [1.3.3.2 生命周期](#1332-生命周期)
  * [1.4 运算符和表达式](#14-运算符和表达式)
    * [1.4.1 算术运算符](#141-算术运算符)
      * [1.4.1.1 基本算术运算符](#1411-基本算术运算符)
      * [1.4.1.2 递增和递减运算符](#1412-递增和递减运算符)
    * [1.4.2 关系运算符](#142-关系运算符)
      * [1.4.2.1 等于和不等于](#1421-等于和不等于)
      * [1.4.2.2 大于和小于](#1422-大于和小于)
    * [1.4.3 逻辑运算符](#143-逻辑运算符)
      * [1.4.3.1 与](#1431-与)
      * [1.4.3.2 或](#1432-或)
      * [1.4.3.3 非](#1433-非)
    * [1.4.4 位运算符](#144-位运算符)
      * [1.4.4.1 与](#1441-与)
      * [1.4.4.2 或](#1442-或)
      * [1.4.4.3 异或](#1443-异或)
      * [1.4.4.4 取反](#1444-取反)
      * [1.4.4.5 左移](#1445-左移)
      * [1.4.4.6 右移](#1446-右移)
    * [1.4.5 条件运算符](#145-条件运算符)
      * [1.4.5.1 三元运算符](#1451-三元运算符)
  * [1.5 控制结构](#15-控制结构)
    * [1.5.1 if-else 语句](#151-if-else-语句)
      * [1.5.1.1 单分支](#1511-单分支)
      * [1.5.1.2 双分支](#1512-双分支)
      * [1.5.1.3 多分支](#1513-多分支)
    * [1.5.2 switch-case 语句](#152-switch-case-语句)
      * [1.5.2.1 switch 的使用](#1521-switch-的使用)
      * [1.5.2.2 case 和 default](#1522-case-和-default)
    * [1.5.3 循环](#153-循环)
      * [1.5.3.1 for 循环](#1531-for-循环)
        * [1.5.3.1.1 语法结构](#15311-语法结构)
        * [1.5.3.1.2 使用示例](#15312-使用示例)
      * [1.5.3.2 while 循环](#1532-while-循环)
        * [1.5.3.2.1 语法结构](#15321-语法结构)
        * [1.5.3.2.2 使用示例](#15322-使用示例)
      * [1.5.3.3 do-while 循环](#1533-do-while-循环)
        * [1.5.3.3.1 语法结构](#15331-语法结构)
        * [1.5.3.3.2 使用示例](#15332-使用示例)
      * [1.5.3.4 循环控制 (break, continue)](#1534-循环控制-break-continue)
        * [1.5.3.4.1 break 的使用](#15341-break-的使用)
        * [1.5.3.4.2 continue 的使用](#15342-continue-的使用)
* [2. 函数](#2-函数)
  * [2.1 函数定义和声明](#21-函数定义和声明)
    * [2.1.1 函数的基本结构](#211-函数的基本结构)
      * [2.1.1.1 函数头](#2111-函数头)
      * [2.1.1.2 函数体](#2112-函数体)
    * [2.1.2 函数声明与定义](#212-函数声明与定义)
      * [2.1.2.1 函数声明](#2121-函数声明)
      * [2.1.2.2 函数定义](#2122-函数定义)
    * [2.1.3 函数调用](#213-函数调用)
      * [2.1.3.1 调用函数](#2131-调用函数)
      * [2.1.3.2 传递参数](#2132-传递参数)
  * [2.2 函数参数和返回值](#22-函数参数和返回值)
    * [2.2.1 值传递](#221-值传递)
      * [2.2.1.1 定义](#2211-定义)
      * [2.2.1.2 示例](#2212-示例)
    * [2.2.2 引用传递](#222-引用传递)
      * [2.2.2.1 定义](#2221-定义)
      * [2.2.2.2 示例](#2222-示例)
    * [2.2.3 指针传递](#223-指针传递)
      * [2.2.3.1 定义](#2231-定义)
      * [2.2.3.2 示例](#2232-示例)
    * [2.2.4 默认参数](#224-默认参数)
      * [2.2.4.1 定义](#2241-定义)
      * [2.2.4.2 示例](#2242-示例)
    * [2.2.5 返回值类型](#225-返回值类型)
      * [2.2.5.1 基本返回类型](#2251-基本返回类型)
      * [2.2.5.2 引用和指针作为返回值](#2252-引用和指针作为返回值)
  * [2.3 函数重载](#23-函数重载)
    * [2.3.1 重载的定义](#231-重载的定义)
      * [2.3.1.1 定义](#2311-定义)
    * [2.3.2 重载的规则](#232-重载的规则)
      * [2.3.2.1 区分重载函数](#2321-区分重载函数)
    * [2.3.3 重载的使用场景](#233-重载的使用场景)
      * [2.3.3.1 示例](#2331-示例)
  * [2.4 内联函数](#24-内联函数)
    * [2.4.1 内联函数的定义](#241-内联函数的定义)
      * [2.4.1.1 定义](#2411-定义)
    * [2.4.2 内联函数的使用](#242-内联函数的使用)
      * [2.4.2.1 示例](#2421-示例)
    * [2.4.3 内联函数的优缺点](#243-内联函数的优缺点)
      * [2.4.3.1 优点](#2431-优点)
      * [2.4.3.2 缺点](#2432-缺点)
  * [2.5 递归函数](#25-递归函数)
    * [2.5.1 递归的基本概念](#251-递归的基本概念)
      * [2.5.1.1 定义](#2511-定义)
    * [2.5.2 递归的实现](#252-递归的实现)
      * [2.5.2.1 基本结构](#2521-基本结构)
      * [2.5.2.2 示例](#2522-示例)
    * [2.5.3 递归的优势与劣势](#253-递归的优势与劣势)
      * [2.5.3.1 优势](#2531-优势)
      * [2.5.3.2 劣势](#2532-劣势)
    * [2.5.4 常见的递归问题](#254-常见的递归问题)
      * [2.5.4.1 示例问题](#2541-示例问题)
* [3. 面向对象编程](#3-面向对象编程)
  * [3.1 类和对象](#31-类和对象)
    * [3.1.1 类的定义](#311-类的定义)
      * [3.1.1.1 基本概念](#3111-基本概念)
      * [3.1.1.2 示例](#3112-示例)
    * [3.1.2 对象的创建](#312-对象的创建)
      * [3.1.2.1 基本概念](#3121-基本概念)
      * [3.1.2.2 示例](#3122-示例)
    * [3.1.3 成员变量与成员函数](#313-成员变量与成员函数)
      * [3.1.3.1 成员变量](#3131-成员变量)
      * [3.1.3.2 成员函数](#3132-成员函数)
  * [3.2 构造函数和析构函数](#32-构造函数和析构函数)
    * [3.2.1 默认构造函数](#321-默认构造函数)
      * [3.2.1.1 定义](#3211-定义)
      * [3.2.1.2 示例](#3212-示例)
    * [3.2.2 有参构造函数](#322-有参构造函数)
      * [3.2.2.1 定义](#3221-定义)
      * [3.2.2.2 示例](#3222-示例)
    * [3.2.3 拷贝构造函数](#323-拷贝构造函数)
      * [3.2.3.1 定义](#3231-定义)
      * [3.2.3.2 示例](#3232-示例)
    * [3.2.4 析构函数](#324-析构函数)
      * [3.2.4.1 定义](#3241-定义)
      * [3.2.4.2 示例](#3242-示例)
  * [3.3 访问控制 (public, private, protected)](#33-访问控制-public-private-protected)
    * [3.3.1 访问控制符的作用](#331-访问控制符的作用)
      * [3.3.1.1 定义](#3311-定义)
      * [3.3.1.2 示例](#3312-示例)
    * [3.3.2 public、private 和 protected 的区别](#332-publicprivate-和-protected-的区别)
      * [3.3.2.1 定义](#3321-定义)
      * [3.3.2.2 示例](#3322-示例)
    * [3.3.3 访问控制的使用场景](#333-访问控制的使用场景)
      * [3.3.3.1 示例](#3331-示例)
  * [3.4 继承](#34-继承)
    * [3.4.1 继承的基本概念](#341-继承的基本概念)
      * [3.4.1.1 定义](#3411-定义)
      * [3.4.1.2 示例](#3412-示例)
    * [3.4.2 基类与派生类](#342-基类与派生类)
      * [3.4.2.1 定义](#3421-定义)
      * [3.4.2.2 示例](#3422-示例)
    * [3.4.3 单继承与多继承](#343-单继承与多继承)
      * [3.4.3.1 定义](#3431-定义)
      * [3.4.3.2 示例](#3432-示例)
    * [3.4.4 继承中的访问控制](#344-继承中的访问控制)
      * [3.4.4.1 定义](#3441-定义)
      * [3.4.4.2 示例](#3442-示例)
  * [3.5 多态](#35-多态)
    * [3.5.1 多态的基本概念](#351-多态的基本概念)
      * [3.5.1.1 定义](#3511-定义)
      * [3.5.1.2 示例](#3512-示例)
    * [3.5.2 虚函数](#352-虚函数)
      * [3.5.2.1 虚函数的定义](#3521-虚函数的定义)
      * [3.5.2.2 虚函数的实现](#3522-虚函数的实现)
      * [3.5.2.3 虚函数的作用](#3523-虚函数的作用)
    * [3.5.3 纯虚函数和抽象类](#353-纯虚函数和抽象类)
      * [3.5.3.1 纯虚函数的定义](#3531-纯虚函数的定义)
      * [3.5.3.2 抽象类的概念](#3532-抽象类的概念)
      * [3.5.3.3 抽象类的使用场景](#3533-抽象类的使用场景)
  * [3.6 运算符重载](#36-运算符重载)
    * [3.6.1 运算符重载的定义](#361-运算符重载的定义)
      * [3.6.1.1 定义](#3611-定义)
      * [3.6.1.2 示例](#3612-示例)
    * [3.6.2 运算符重载的规则](#362-运算符重载的规则)
      * [3.6.2.1 定义](#3621-定义)
      * [3.6.2.2 示例](#3622-示例)
    * [3.6.3 常见的运算符重载](#363-常见的运算符重载)
      * [3.6.3.1 算术运算符](#3631-算术运算符)
      * [3.6.3.2 关系运算符](#3632-关系运算符)
      * [3.6.3.3 赋值运算符](#3633-赋值运算符)
      * [3.6.3.4 输入输出运算符](#3634-输入输出运算符)
  * [3.7 类和对象的动态内存分配](#37-类和对象的动态内存分配)
    * [3.7.1 new 和 delete 操作符](#371-new-和-delete-操作符)
      * [3.7.1.1 定义](#3711-定义)
      * [3.7.1.2 示例](#3712-示例)
    * [3.7.2 动态内存分配的注意事项](#372-动态内存分配的注意事项)
      * [3.7.2.1 定义](#3721-定义)
      * [3.7.2.2 示例](#3722-示例)
    * [3.7.3 智能指针](#373-智能指针)
      * [3.7.3.1 定义](#3731-定义)
      * [3.7.3.2 示例](#3732-示例)
  * [3.8 关键字](#38-关键字)
    * [3.8.1 指针与引用](#381-指针与引用)
      * [3.8.1.1 定义](#3811-定义)
      * [3.8.1.2 示例](#3812-示例)
    * [3.8.2 static](#382-static)
      * [3.8.2.1 定义](#3821-定义)
      * [3.8.2.2 示例](#3822-示例)
    * [3.8.3 前置++与后置++](#383-前置与后置)
      * [3.8.3.1 定义](#3831-定义)
      * [3.8.3.2 示例](#3832-示例)
    * [3.8.4 std::atomic](#384-stdatomic)
      * [3.8.4.1 定义](#3841-定义)
      * [3.8.4.2 示例](#3842-示例)
    * [3.8.5 const 关键字](#385-const-关键字)
      * [3.8.5.1 定义](#3851-定义)
      * [3.8.5.2 示例](#3852-示例)
    * [3.8.6 define 和 typedef 的区别](#386-define-和-typedef-的区别)
      * [3.8.6.1 定义](#3861-定义)
      * [3.8.6.2 示例](#3862-示例)
    * [3.8.7 define 和 inline 的区别](#387-define-和-inline-的区别)
      * [3.8.7.1 定义](#3871-定义)
      * [3.8.7.2 示例](#3872-示例)
    * [3.8.8 override 和 overload](#388-override-和-overload)
      * [3.8.8.1 定义](#3881-定义)
      * [3.8.8.2 示例](#3882-示例)
    * [3.8.9 new 和 malloc](#389-new-和-malloc)
      * [3.8.9.1 定义](#3891-定义)
      * [3.8.9.2 示例](#3892-示例)
    * [3.8.10 constexpr 和 const](#3810-constexpr-和-const)
      * [3.8.10.1 定义](#38101-定义)
      * [3.8.10.2 示例](#38102-示例)
    * [3.8.11 volatile](#3811-volatile)
      * [3.8.11.1 定义](#38111-定义)
      * [3.8.11.2 示例](#38112-示例)
    * [3.8.12 extern](#3812-extern)
      * [3.8.12.1 定义](#38121-定义)
      * [3.8.12.2 示例](#38122-示例)
* [4. 标准模板库 (STL)](#4-标准模板库-stl)
  * [4.1 容器](#41-容器)
    * [4.1.1 vector](#411-vector)
      * [4.1.1.1 定义与使用](#4111-定义与使用)
      * [4.1.1.2 常用操作函数](#4112-常用操作函数)
      * [4.1.1.3 迭代器](#4113-迭代器)
    * [4.1.2 list](#412-list)
      * [4.1.2.1 定义与使用](#4121-定义与使用)
      * [4.1.2.2 常用操作函数](#4122-常用操作函数)
      * [4.1.2.3 迭代器](#4123-迭代器)
    * [4.1.3 deque](#413-deque)
      * [4.1.3.1 定义与使用](#4131-定义与使用)
      * [4.1.3.2 常用操作函数](#4132-常用操作函数)
      * [4.1.3.3 迭代器](#4133-迭代器)
    * [4.1.4 set 和 unordered\_set](#414-set-和-unordered_set)
      * [4.1.4.1 定义与使用](#4141-定义与使用)
      * [4.1.4.2 常用操作函数](#4142-常用操作函数)
      * [4.1.4.3 迭代器](#4143-迭代器)
    * [4.1.5 map 和 unordered\_map](#415-map-和-unordered_map)
      * [4.1.5.1 定义与使用](#4151-定义与使用)
      * [4.1.5.2 常用操作函数](#4152-常用操作函数)
      * [4.1.5.3 迭代器](#4153-迭代器)
    * [4.1.6 heap](#416-heap)
      * [4.1.6.1 定义与使用](#4161-定义与使用)
      * [4.1.6.2 常用操作函数](#4162-常用操作函数)
    * [4.1.7 priority\_queue](#417-priority_queue)
      * [4.1.7.1 定义与使用](#4171-定义与使用)
      * [4.1.7.2 常用操作函数](#4172-常用操作函数)
  * [4.2 迭代器](#42-迭代器)
    * [4.2.1 基本概念](#421-基本概念)
      * [4.2.1.1 定义](#4211-定义)
    * [4.2.2 迭代器的类型](#422-迭代器的类型)
      * [4.2.2.1 输入迭代器](#4221-输入迭代器)
      * [4.2.2.2 输出迭代器](#4222-输出迭代器)
      * [4.2.2.3 前向迭代器](#4223-前向迭代器)
      * [4.2.2.4 双向迭代器](#4224-双向迭代器)
      * [4.2.2.5 随机访问迭代器](#4225-随机访问迭代器)
    * [4.2.3 迭代器的操作](#423-迭代器的操作)
      * [4.2.3.1 迭代器的初始化](#4231-迭代器的初始化)
      * [4.2.3.2 迭代器的移动](#4232-迭代器的移动)
      * [4.2.3.3 迭代器的比较](#4233-迭代器的比较)
  * [4.3 算法](#43-算法)
    * [4.3.1 常用算法](#431-常用算法)
      * [4.3.1.1 排序算法](#4311-排序算法)
      * [4.3.1.2 查找算法](#4312-查找算法)
      * [4.3.1.3 变换算法](#4313-变换算法)
    * [4.3.2 算法的使用](#432-算法的使用)
      * [4.3.2.1 sort](#4321-sort)
      * [4.3.2.2 find](#4322-find)
      * [4.3.2.3 transform](#4323-transform)
  * [4.4 仿函数 (functors)](#44-仿函数-functors)
    * [4.4.1 定义](#441-定义)
      * [4.4.1.1 基本概念](#4411-基本概念)
      * [4.4.1.2 示例](#4412-示例)
    * [4.4.2 使用](#442-使用)
      * [4.4.2.1 常见使用场景](#4421-常见使用场景)
    * [4.4.3 自定义仿函数](#443-自定义仿函数)
      * [4.4.3.1 定义](#4431-定义)
      * [4.4.3.2 示例](#4432-示例)
  * [4.5 适配器](#45-适配器)
    * [4.5.1 定义](#451-定义)
      * [4.5.1.1 基本概念](#4511-基本概念)
      * [4.5.1.2 示例](#4512-示例)
    * [4.5.2 常见适配器](#452-常见适配器)
      * [4.5.2.1 迭代器适配器](#4521-迭代器适配器)
      * [4.5.2.2 函数适配器](#4522-函数适配器)
      * [4.5.2.3 容器适配器](#4523-容器适配器)
  * [4.6 空间适配器](#46-空间适配器)
    * [4.6.1 定义](#461-定义)
      * [4.6.1.1 基本概念](#4611-基本概念)
      * [4.6.1.2 示例](#4612-示例)
    * [4.6.2 常见空间适配器](#462-常见空间适配器)
      * [4.6.2.1 allocator](#4621-allocator)
      * [4.6.2.2 示例](#4622-示例)
* [5. 高级特性](#5-高级特性)
  * [5.1 模板编程](#51-模板编程)
    * [5.1.1 基本概念](#511-基本概念)
    * [5.1.2 函数模板](#512-函数模板)
      * [5.1.2.1 定义与使用](#5121-定义与使用)
      * [5.1.2.2 示例代码](#5122-示例代码)
    * [5.1.3 类模板](#513-类模板)
      * [5.1.3.1 定义与使用](#5131-定义与使用)
      * [5.1.3.2 示例代码](#5132-示例代码)
    * [5.1.4 模板特化](#514-模板特化)
      * [5.1.4.1 定义与使用](#5141-定义与使用)
      * [5.1.4.2 示例代码](#5142-示例代码)
  * [5.2 异常处理](#52-异常处理)
    * [5.2.1 基本概念](#521-基本概念)
    * [5.2.2 try-catch 语句](#522-try-catch-语句)
      * [5.2.2.1 定义与使用](#5221-定义与使用)
      * [5.2.2.2 示例代码](#5222-示例代码)
    * [5.2.3 throw 语句](#523-throw-语句)
      * [5.2.3.1 定义与使用](#5231-定义与使用)
      * [5.2.3.2 示例代码](#5232-示例代码)
    * [5.2.4 自定义异常](#524-自定义异常)
      * [5.2.4.1 定义与使用](#5241-定义与使用)
      * [5.2.4.2 示例代码](#5242-示例代码)
  * [5.3 智能指针](#53-智能指针)
    * [5.3.1 基本概念](#531-基本概念)
    * [5.3.2 shared\_ptr](#532-shared_ptr)
      * [5.3.2.1 定义与使用](#5321-定义与使用)
      * [5.3.2.2 示例代码](#5322-示例代码)
    * [5.3.3 unique\_ptr](#533-unique_ptr)
      * [5.3.3.1 定义与使用](#5331-定义与使用)
      * [5.3.3.2 示例代码](#5332-示例代码)
    * [5.3.4 weak\_ptr](#534-weak_ptr)
      * [5.3.4.1 定义与使用](#5341-定义与使用)
      * [5.3.4.2 示例代码](#5342-示例代码)
  * [5.4 多线程](#54-多线程)
    * [5.4.1 基本概念](#541-基本概念)
    * [5.4.2 线程的创建与管理](#542-线程的创建与管理)
      * [5.4.2.1 定义与使用](#5421-定义与使用)
      * [5.4.2.2 示例代码](#5422-示例代码)
    * [5.4.3 线程同步](#543-线程同步)
      * [5.4.3.1 基本概念](#5431-基本概念)
      * [5.4.3.2 mutex](#5432-mutex)
        * [5.4.3.2.1 定义与使用](#54321-定义与使用)
        * [5.4.3.2.2 示例代码](#54322-示例代码)
      * [5.4.3.3 lock\_guard](#5433-lock_guard)
        * [5.4.3.3.1 定义与使用](#54331-定义与使用)
        * [5.4.3.3.2 示例代码](#54332-示例代码)
      * [5.4.3.4 condition\_variable](#5434-condition_variable)
        * [5.4.3.4.1 定义与使用](#54341-定义与使用)
        * [5.4.3.4.2 示例代码](#54342-示例代码)
  * [5.5 标准库 (Standard Library)](#55-标准库-standard-library)
    * [5.5.1 I/O 库](#551-io-库)
      * [5.5.1.1 基本概念](#5511-基本概念)
      * [5.5.1.2 cin, cout, cerr](#5512-cin-cout-cerr)
        * [5.5.1.2.1 定义与使用](#55121-定义与使用)
        * [5.5.1.2.2 示例代码](#55122-示例代码)
      * [5.5.1.3 文件 I/O](#5513-文件-io)
        * [5.5.1.3.1 定义与使用](#55131-定义与使用)
        * [5.5.1.3.2 示例代码](#55132-示例代码)
    * [5.5.2 字符串处理](#552-字符串处理)
      * [5.5.2.1 string 类](#5521-string-类)
        * [5.5.2.1.1 定义与使用](#55211-定义与使用)
        * [5.5.2.1.2 示例代码](#55212-示例代码)
      * [5.5.2.2 常用字符串操作函数](#5522-常用字符串操作函数)
        * [5.5.2.2.1 定义与使用](#55221-定义与使用)
        * [5.5.2.2.2 示例代码](#55222-示例代码)
    * [5.5.3 日期和时间](#553-日期和时间)
      * [5.5.3.1 chrono 库](#5531-chrono-库)
        * [5.5.3.1.1 定义与使用](#55311-定义与使用)
        * [5.5.3.1.2 示例代码](#55312-示例代码)
      * [5.5.3.2 时间的获取与格式化](#5532-时间的获取与格式化)
        * [5.5.3.2.1 定义与使用](#55321-定义与使用)
        * [5.5.3.2.2 示例代码](#55322-示例代码)
* [6. 设计模式](#6-设计模式)
  * [6.1 单例模式](#61-单例模式)
    * [6.1.1 基本概念](#611-基本概念)
    * [6.1.2 实现方法](#612-实现方法)
      * [6.1.2.1 饿汉式](#6121-饿汉式)
      * [6.1.2.2 懒汉式](#6122-懒汉式)
      * [6.1.2.3 双重检查锁](#6123-双重检查锁)
    * [6.1.3 示例代码](#613-示例代码)
    * [6.1.4 单例模式的应用场景](#614-单例模式的应用场景)
  * [6.2 工厂模式](#62-工厂模式)
    * [6.2.1 基本概念](#621-基本概念)
    * [6.2.2 实现方法](#622-实现方法)
      * [6.2.2.1 简单工厂](#6221-简单工厂)
      * [6.2.2.2 工厂方法](#6222-工厂方法)
      * [6.2.2.3 抽象工厂](#6223-抽象工厂)
    * [6.2.3 示例代码](#623-示例代码)
    * [6.2.4 工厂模式的应用场景](#624-工厂模式的应用场景)
  * [6.3 观察者模式](#63-观察者模式)
    * [6.3.1 基本概念](#631-基本概念)
    * [6.3.2 实现方法](#632-实现方法)
      * [6.3.2.1 传统实现](#6321-传统实现)
      * [6.3.2.2 使用 STL](#6322-使用-stl)
    * [6.3.3 示例代码](#633-示例代码)
    * [6.3.4 观察者模式的应用场景](#634-观察者模式的应用场景)
  * [6.4 访问者模式](#64-访问者模式)
    * [6.4.1 基本概念](#641-基本概念)
    * [6.4.2 实现方法](#642-实现方法)
      * [6.4.2.1 传统实现](#6421-传统实现)
      * [6.4.2.2 使用 STL](#6422-使用-stl)
    * [6.4.3 示例代码](#643-示例代码)
    * [6.4.4 访问者模式的应用场景](#644-访问者模式的应用场景)
* [7. 实践问题及解答](#7-实践问题及解答)
  * [7.1 常见编译错误](#71-常见编译错误)
    * [7.1.1 语法错误](#711-语法错误)
    * [7.1.2 链接错误](#712-链接错误)
    * [7.1.3 运行时错误](#713-运行时错误)
  * [7.2 内存管理问题](#72-内存管理问题)
    * [7.2.1 内存泄漏](#721-内存泄漏)
    * [7.2.2 悬挂指针](#722-悬挂指针)
    * [7.2.3 缓冲区溢出](#723-缓冲区溢出)
  * [7.3 性能优化](#73-性能优化)
    * [7.3.1 编译器优化](#731-编译器优化)
    * [7.3.2 代码优化](#732-代码优化)
    * [7.3.3 数据结构选择](#733-数据结构选择)
  * [7.4 代码风格和最佳实践](#74-代码风格和最佳实践)
    * [7.4.1 命名规范](#741-命名规范)
    * [7.4.2 注释规范](#742-注释规范)
    * [7.4.3 代码格式化](#743-代码格式化)
    * [7.4.4 重构](#744-重构)
* [8. C++11, 14, 17, 20 等新特性](#8-c11-14-17-20-等新特性)
  * [8.1 C++11 新特性](#81-c11-新特性)
    * [8.1.1 auto 关键字](#811-auto-关键字)
    * [8.1.2 lambda 表达式](#812-lambda-表达式)
    * [8.1.3 智能指针](#813-智能指针)
    * [8.1.4 右值引用和移动语义](#814-右值引用和移动语义)
    * [8.1.5 其他新特性](#815-其他新特性)
  * [8.2 C++14 新特性](#82-c14-新特性)
    * [8.2.1 lambda 表达式的增强](#821-lambda-表达式的增强)
    * [8.2.2 std::make\_unique](#822-stdmake_unique)
    * [8.2.3 二进制字面值](#823-二进制字面值)
    * [8.2.4 其他新特性](#824-其他新特性)
  * [8.3 C++17 新特性](#83-c17-新特性)
    * [8.3.1 std::optional](#831-stdoptional)
    * [8.3.2 std::variant](#832-stdvariant)
    * [8.3.3 std::any](#833-stdany)
    * [8.3.4 结构化绑定](#834-结构化绑定)
    * [8.3.5 if constexpr](#835-if-constexpr)
    * [8.3.6 其他新特性](#836-其他新特性)
  * [8.4 C++20 新特性](#84-c20-新特性)
    * [8.4.1 模块 (Modules)](#841-模块-modules)
    * [8.4.2 协程 (Coroutines)](#842-协程-coroutines)
    * [8.4.3 范围 (Ranges)](#843-范围-ranges)
    * [8.4.4 概念 (Concepts)](#844-概念-concepts)
    * [8.4.5 三路比较运算符 (\<=\>)](#845-三路比较运算符-)
    * [8.4.6 日志库 (std::format)](#846-日志库-stdformat)
    * [8.4.7 其他改进](#847-其他改进)
* [9. 项目和练习](#9-项目和练习)
  * [9.1 小型项目](#91-小型项目)
    * [9.1.1 学生成绩管理系统](#911-学生成绩管理系统)
    * [9.1.2 图书管理系统](#912-图书管理系统)
  * [9.2 代码挑战和练习题](#92-代码挑战和练习题)
    * [9.2.1 挑战1：排序算法的实现](#921-挑战1排序算法的实现)
    * [9.2.2 挑战2：数据结构的实现](#922-挑战2数据结构的实现)
  * [9.3 实践项目](#93-实践项目)
    * [9.3.1 简易Web服务器](#931-简易web服务器)
    * [9.3.2 聊天应用程序](#932-聊天应用程序)
  * [9.4 其他练习题](#94-其他练习题)
    * [9.4.1 练习题1](#941-练习题1)
    * [9.4.2 练习题2](#942-练习题2)
  * [9.5 项目心得和总结](#95-项目心得和总结)
* [10. 参考资料](#10-参考资料)
  * [10.1 书籍推荐](#101-书籍推荐)
    * [10.1.1 《C++ Primer》](#1011-c-primer)
    * [10.1.2 《Effective C++》](#1012-effective-c)
    * [10.1.3 《The C++ Programming Language》](#1013-the-c-programming-language)
    * [10.1.4 其他推荐书籍](#1014-其他推荐书籍)
  * [10.2 在线资源](#102-在线资源)
    * [10.2.1 C++ 官方文档](#1021-c-官方文档)
    * [10.2.2 C++ 教程网站](#1022-c-教程网站)
    * [10.2.3 C++ 社区论坛](#1023-c-社区论坛)
  * [10.3 常用库和框架](#103-常用库和框架)
    * [10.3.1 Boost](#1031-boost)
    * [10.3.2 Qt](#1032-qt)
    * [10.3.3 POCO](#1033-poco)
    * [10.3.4 其他常用库](#1034-其他常用库)
  * [10.4 常见问题与解答](#104-常见问题与解答)
    * [10.4.1 编译错误](#1041-编译错误)
    * [10.4.2 链接错误](#1042-链接错误)
    * [10.4.3 运行时错误](#1043-运行时错误)
  * [10.5 代码风格和最佳实践](#105-代码风格和最佳实践)
    * [10.5.1 命名规范](#1051-命名规范)
    * [10.5.2 注释规范](#1052-注释规范)
    * [10.5.3 代码格式化](#1053-代码格式化)
    * [10.5.4 重构](#1054-重构)
  * [10.6 学习心得和建议](#106-学习心得和建议)


## 1. 基础知识

### 1.1 C++ 简介

#### 1.1.1 C++ 的历史和发展

##### 1.1.1.1 简介
介绍C++语言的诞生背景和基本概念。

##### 1.1.1.2 发展历程
描述C++语言的发展历程和主要版本的变化。

#### 1.1.2 C++ 与 C 的区别

##### 1.1.2.1 语法差异
列出并解释C++与C在语法上的主要差异。

##### 1.1.2.2 功能差异
讨论C++相对于C增加的主要功能和特性。

#### 1.1.3 C++ 的应用领域

##### 1.1.3.1 系统编程
描述C++在系统编程中的应用，包括操作系统开发和底层驱动程序。

##### 1.1.3.2 游戏开发
介绍C++在游戏开发中的重要性和应用实例。

##### 1.1.3.3 嵌入式系统
讲述C++在嵌入式系统中的应用，包括设备控制和实时操作系统。

### 1.2 数据类型

#### 1.2.1 基本数据类型

##### 1.2.1.1 整型
介绍整型数据类型及其使用。

##### 1.2.1.2 浮点型
讲解浮点型数据类型及其使用。

##### 1.2.1.3 字符型
描述字符型数据类型及其使用。

#### 1.2.2 用户定义类型

##### 1.2.2.1 枚举
介绍枚举类型的定义和使用。

##### 1.2.2.2 结构体
讲解结构体的定义和使用。

##### 1.2.2.3 联合体
描述联合体的定义和使用。

#### 1.2.3 类型转换

##### 1.2.3.1 隐式转换
介绍隐式类型转换及其规则。

##### 1.2.3.2 显式转换
讲解显式类型转换的方法和使用场景。

### 1.3 变量和常量

#### 1.3.1 变量的声明与定义

##### 1.3.1.1 声明
介绍变量声明的语法和规则。

##### 1.3.1.2 定义
讲解变量定义的语法和规则。

##### 1.3.1.3 初始化
描述变量初始化的方法和注意事项。

#### 1.3.2 常量的定义与使用

##### 1.3.2.1 常量的定义
介绍常量的定义方法和语法。

##### 1.3.2.2 常量的使用
讲解如何在代码中使用常量。

#### 1.3.3 作用域和生命周期

##### 1.3.3.1 作用域
描述变量和常量的作用域规则。

##### 1.3.3.2 生命周期
讲解变量和常量的生命周期和内存管理。

### 1.4 运算符和表达式

#### 1.4.1 算术运算符

##### 1.4.1.1 基本算术运算符
介绍基本算术运算符（如加、减、乘、除）的使用。

##### 1.4.1.2 递增和递减运算符
讲解递增（++）和递减（--）运算符的使用。

#### 1.4.2 关系运算符

##### 1.4.2.1 等于和不等于
描述等于（==）和不等于（!=）运算符的使用。

##### 1.4.2.2 大于和小于
讲解大于（>）、小于（<）及其变体（>=、<=）运算符的使用。

#### 1.4.3 逻辑运算符

##### 1.4.3.1 与
介绍逻辑与（&&）运算符的使用。

##### 1.4.3.2 或
描述逻辑或（||）运算符的使用。

##### 1.4.3.3 非
讲解逻辑非（!）运算符的使用。

#### 1.4.4 位运算符

##### 1.4.4.1 与
介绍位与（&）运算符的使用。

##### 1.4.4.2 或
描述位或（|）运算符的使用。

##### 1.4.4.3 异或
讲解位异或（^）运算符的使用。

##### 1.4.4.4 取反
介绍位取反（~）运算符的使用。

##### 1.4.4.5 左移
描述左移（<<）运算符的使用。

##### 1.4.4.6 右移
讲解右移（>>）运算符的使用。

#### 1.4.5 条件运算符

##### 1.4.5.1 三元运算符
介绍三元运算符（?:）的使用。

### 1.5 控制结构

#### 1.5.1 if-else 语句

##### 1.5.1.1 单分支
介绍单分支if语句的使用。

##### 1.5.1.2 双分支
描述双分支if-else语句的使用。

##### 1.5.1.3 多分支
讲解多分支if-else if-else语句的使用。

#### 1.5.2 switch-case 语句

##### 1.5.2.1 switch 的使用
介绍switch语句的基本语法和使用。

##### 1.5.2.2 case 和 default
描述case标签和default标签的使用。

#### 1.5.3 循环

##### 1.5.3.1 for 循环

###### 1.5.3.1.1 语法结构
介绍for循环的语法结构。

###### 1.5.3.1.2 使用示例
提供for循环的使用示例。

##### 1.5.3.2 while 循环

###### 1.5.3.2.1 语法结构
介绍while循环的语法结构。

###### 1.5.3.2.2 使用示例
提供while循环的使用示例。

##### 1.5.3.3 do-while 循环

###### 1.5.3.3.1 语法结构
介绍do-while循环的语法结构。

###### 1.5.3.3.2 使用示例
提供do-while循环的使用示例。

##### 1.5.3.4 循环控制 (break, continue)

###### 1.5.3.4.1 break 的使用
介绍break语句的使用。

###### 1.5.3.4.2 continue 的使用
描述continue语句的使用。

## 2. 函数

### 2.1 函数定义和声明

#### 2.1.1 函数的基本结构

##### 2.1.1.1 函数头
介绍函数头部的组成部分，包括返回类型、函数名和参数列表。

##### 2.1.1.2 函数体
讲解函数体的结构和编写方法。

#### 2.1.2 函数声明与定义

##### 2.1.2.1 函数声明
描述函数声明的语法和作用。

##### 2.1.2.2 函数定义
讲解函数定义的语法和示例。

#### 2.1.3 函数调用

##### 2.1.3.1 调用函数
介绍如何在代码中调用已定义的函数。

##### 2.1.3.2 传递参数
讲解函数调用时参数的传递方式和规则。

### 2.2 函数参数和返回值

#### 2.2.1 值传递

##### 2.2.1.1 定义
介绍值传递的定义和基本概念。

##### 2.2.1.2 示例
提供值传递的代码示例。

#### 2.2.2 引用传递

##### 2.2.2.1 定义
介绍引用传递的定义和基本概念。

##### 2.2.2.2 示例
提供引用传递的代码示例。

#### 2.2.3 指针传递

##### 2.2.3.1 定义
介绍指针传递的定义和基本概念。

##### 2.2.3.2 示例
提供指针传递的代码示例。

#### 2.2.4 默认参数

##### 2.2.4.1 定义
介绍默认参数的定义和使用方法。

##### 2.2.4.2 示例
提供包含默认参数的函数定义和调用示例。

#### 2.2.5 返回值类型

##### 2.2.5.1 基本返回类型
讲解函数的基本返回类型及其使用。

##### 2.2.5.2 引用和指针作为返回值
介绍引用和指针作为返回值的用法和注意事项。

### 2.3 函数重载

#### 2.3.1 重载的定义

##### 2.3.1.1 定义
介绍函数重载的定义和基本概念。

#### 2.3.2 重载的规则

##### 2.3.2.1 区分重载函数
讲解如何区分重载函数，包括参数个数、类型和顺序的不同。

#### 2.3.3 重载的使用场景

##### 2.3.3.1 示例
提供函数重载的代码示例和应用场景。

### 2.4 内联函数

#### 2.4.1 内联函数的定义

##### 2.4.1.1 定义
介绍内联函数的定义和基本概念。

#### 2.4.2 内联函数的使用

##### 2.4.2.1 示例
提供内联函数的代码示例。

#### 2.4.3 内联函数的优缺点

##### 2.4.3.1 优点
介绍使用内联函数的主要优点。

##### 2.4.3.2 缺点
讲解使用内联函数可能带来的缺点和限制。

### 2.5 递归函数

#### 2.5.1 递归的基本概念

##### 2.5.1.1 定义
介绍递归的定义和基本概念。

#### 2.5.2 递归的实现

##### 2.5.2.1 基本结构
讲解递归函数的基本结构和实现方法。

##### 2.5.2.2 示例
提供递归函数的代码示例。

#### 2.5.3 递归的优势与劣势

##### 2.5.3.1 优势
介绍递归的主要优势，包括代码简洁性和解决复杂问题的能力。

##### 2.5.3.2 劣势
讲解递归可能带来的劣势，如栈溢出和性能问题。

#### 2.5.4 常见的递归问题

##### 2.5.4.1 示例问题
提供一些常见的递归问题及其解决方案，如斐波那契数列和阶乘计算。

## 3. 面向对象编程

### 3.1 类和对象

#### 3.1.1 类的定义

##### 3.1.1.1 基本概念
介绍类的基本概念和结构。

##### 3.1.1.2 示例
提供类定义的代码示例。

#### 3.1.2 对象的创建

##### 3.1.2.1 基本概念
讲解对象创建的基本方法和概念。

##### 3.1.2.2 示例
提供对象创建的代码示例。

#### 3.1.3 成员变量与成员函数

##### 3.1.3.1 成员变量
介绍成员变量的定义和使用。

##### 3.1.3.2 成员函数
讲解成员函数的定义和使用。

### 3.2 构造函数和析构函数

#### 3.2.1 默认构造函数

##### 3.2.1.1 定义
介绍默认构造函数的定义和使用。

##### 3.2.1.2 示例
提供默认构造函数的代码示例。

#### 3.2.2 有参构造函数

##### 3.2.2.1 定义
介绍有参构造函数的定义和使用。

##### 3.2.2.2 示例
提供有参构造函数的代码示例。

#### 3.2.3 拷贝构造函数

##### 3.2.3.1 定义
介绍拷贝构造函数的定义和使用。

##### 3.2.3.2 示例
提供拷贝构造函数的代码示例。

#### 3.2.4 析构函数

##### 3.2.4.1 定义
介绍析构函数的定义和使用。

##### 3.2.4.2 示例
提供析构函数的代码示例。

### 3.3 访问控制 (public, private, protected)

#### 3.3.1 访问控制符的作用

##### 3.3.1.1 定义
介绍访问控制符的定义和作用。

##### 3.3.1.2 示例
提供使用访问控制符的代码示例。

#### 3.3.2 public、private 和 protected 的区别

##### 3.3.2.1 定义
讲解 public、private 和 protected 的定义和区别。

##### 3.3.2.2 示例
提供 public、private 和 protected 的使用示例。

#### 3.3.3 访问控制的使用场景

##### 3.3.3.1 示例
介绍访问控制在实际编程中的使用场景。

### 3.4 继承

#### 3.4.1 继承的基本概念

##### 3.4.1.1 定义
介绍继承的基本概念和定义。

##### 3.4.1.2 示例
提供继承的代码示例。

#### 3.4.2 基类与派生类

##### 3.4.2.1 定义
讲解基类和派生类的定义和区别。

##### 3.4.2.2 示例
提供基类和派生类的代码示例。

#### 3.4.3 单继承与多继承

##### 3.4.3.1 定义
介绍单继承和多继承的概念和区别。

##### 3.4.3.2 示例
提供单继承和多继承的代码示例。

#### 3.4.4 继承中的访问控制

##### 3.4.4.1 定义
讲解继承中的访问控制规则和使用方法。

##### 3.4.4.2 示例
提供继承中访问控制的代码示例。

### 3.5 多态

#### 3.5.1 多态的基本概念

##### 3.5.1.1 定义
介绍多态的基本概念和定义。

##### 3.5.1.2 示例
提供多态的代码示例。

#### 3.5.2 虚函数

##### 3.5.2.1 虚函数的定义
讲解虚函数的定义和使用。

##### 3.5.2.2 虚函数的实现
介绍虚函数的实现方法和示例。

##### 3.5.2.3 虚函数的作用
提供虚函数在实际编程中的使用场景。

#### 3.5.3 纯虚函数和抽象类

##### 3.5.3.1 纯虚函数的定义
介绍纯虚函数的定义和使用。

##### 3.5.3.2 抽象类的概念
讲解抽象类的概念和定义。

##### 3.5.3.3 抽象类的使用场景
提供抽象类在实际编程中的使用示例。

### 3.6 运算符重载

#### 3.6.1 运算符重载的定义

##### 3.6.1.1 定义
介绍运算符重载的定义和基本概念。

##### 3.6.1.2 示例
提供运算符重载的代码示例。

#### 3.6.2 运算符重载的规则

##### 3.6.2.1 定义
讲解运算符重载的规则和限制。

##### 3.6.2.2 示例
提供运算符重载规则的代码示例。

#### 3.6.3 常见的运算符重载

##### 3.6.3.1 算术运算符
介绍算术运算符的重载方法和示例。

##### 3.6.3.2 关系运算符
讲解关系运算符的重载方法和示例。

##### 3.6.3.3 赋值运算符
提供赋值运算符的重载方法和示例。

##### 3.6.3.4 输入输出运算符
介绍输入输出运算符的重载方法和示例。

### 3.7 类和对象的动态内存分配

#### 3.7.1 new 和 delete 操作符

##### 3.7.1.1 定义
介绍 new 和 delete 操作符的定义和使用。

##### 3.7.1.2 示例
提供 new 和 delete 操作符的代码示例。

#### 3.7.2 动态内存分配的注意事项

##### 3.7.2.1 定义
讲解动态内存分配时的注意事项。

##### 3.7.2.2 示例
提供动态内存分配注意事项的代码示例。

#### 3.7.3 智能指针

##### 3.7.3.1 定义
介绍智能指针的定义和基本概念。

##### 3.7.3.2 示例
提供智能指针的代码示例。

### 3.8 关键字

#### 3.8.1 指针与引用

##### 3.8.1.1 定义
介绍指针和引用的定义和区别。

##### 3.8.1.2 示例
提供指针和引用的代码示例。

#### 3.8.2 static

##### 3.8.2.1 定义
介绍 static 关键字的定义和使用场景。

##### 3.8.2.2 示例
提供 static 关键字的代码示例。

#### 3.8.3 前置++与后置++

##### 3.8.3.1 定义
讲解前置++和后置++的定义和区别。

##### 3.8.3.2 示例
提供前置++和后置++的代码示例。

#### 3.8.4 std::atomic

##### 3.8.4.1 定义
介绍 std::atomic 的定义和使用。

##### 3.8.4.2 示例
提供 std::atomic 的代码示例。

#### 3.8.5 const 关键字

##### 3.8.5.1 定义
讲解 const 关键字的定义和使用。

##### 3.8.5.2 示例
提供 const 关键字的代码示例。

#### 3.8.6 define 和 typedef 的区别

##### 3.8.6.1 定义
介绍 define 和 typedef 的定义和区别。

##### 3.8.6.2 示例
提供 define 和 typedef 的代码示例。

#### 3.8.7 define 和 inline 的区别

##### 3.8.7.1 定义
讲解 define 和 inline 的定义和区别。

##### 3.8.7.2 示例
提供 define 和 inline 的代码示例。

#### 3.8.8 override 和 overload

##### 3.8.8.1 定义
介绍 override 和 overload 的定义和区别。

##### 3.8.8.2 示例
提供 override 和 overload 的代码示例。

#### 3.8.9 new 和 malloc

##### 3.8.9.1 定义
讲解 new 和 malloc 的定义和区别。

##### 3.8.9.2 示例
提供 new 和 malloc 的代码示例。

#### 3.8.10 constexpr 和 const

##### 3.8.10.1 定义
介绍 constexpr 和 const 的定义和区别。

##### 3.8.10.2 示例
提供 constexpr 和 const 的代码示例。

#### 3.8.11 volatile

##### 3.8.11.1 定义
讲解 volatile 的定义和使用场景。

##### 3.8.11.2 示例
提供 volatile 的代码示例。

#### 3.8.12 extern

##### 3.8.12.1 定义
介绍 extern 的定义和使用场景。

##### 3.8.12.2 示例
提供 extern 的代码示例。

## 4. 标准模板库 (STL)

### 4.1 容器

#### 4.1.1 vector

##### 4.1.1.1 定义与使用
介绍 vector 容器的定义和基本使用方法。

##### 4.1.1.2 常用操作函数
讲解 vector 容器的常用操作函数及其使用。

##### 4.1.1.3 迭代器
提供 vector 容器的迭代器使用方法和示例。

#### 4.1.2 list

##### 4.1.2.1 定义与使用
介绍 list 容器的定义和基本使用方法。

##### 4.1.2.2 常用操作函数
讲解 list 容器的常用操作函数及其使用。

##### 4.1.2.3 迭代器
提供 list 容器的迭代器使用方法和示例。

#### 4.1.3 deque

##### 4.1.3.1 定义与使用
介绍 deque 容器的定义和基本使用方法。

##### 4.1.3.2 常用操作函数
讲解 deque 容器的常用操作函数及其使用。

##### 4.1.3.3 迭代器
提供 deque 容器的迭代器使用方法和示例。

#### 4.1.4 set 和 unordered_set

##### 4.1.4.1 定义与使用
介绍 set 和 unordered_set 容器的定义和基本使用方法。

##### 4.1.4.2 常用操作函数
讲解 set 和 unordered_set 容器的常用操作函数及其使用。

##### 4.1.4.3 迭代器
提供 set 和 unordered_set 容器的迭代器使用方法和示例。

#### 4.1.5 map 和 unordered_map

##### 4.1.5.1 定义与使用
介绍 map 和 unordered_map 容器的定义和基本使用方法。

##### 4.1.5.2 常用操作函数
讲解 map 和 unordered_map 容器的常用操作函数及其使用。

##### 4.1.5.3 迭代器
提供 map 和 unordered_map 容器的迭代器使用方法和示例。

#### 4.1.6 heap

##### 4.1.6.1 定义与使用
介绍 heap 容器的定义和基本使用方法。

##### 4.1.6.2 常用操作函数
讲解 heap 容器的常用操作函数及其使用。

#### 4.1.7 priority_queue

##### 4.1.7.1 定义与使用
介绍 priority_queue 容器的定义和基本使用方法。

##### 4.1.7.2 常用操作函数
讲解 priority_queue 容器的常用操作函数及其使用。

### 4.2 迭代器

#### 4.2.1 基本概念

##### 4.2.1.1 定义
介绍迭代器的基本概念和定义。

#### 4.2.2 迭代器的类型

##### 4.2.2.1 输入迭代器
讲解输入迭代器的定义和使用。

##### 4.2.2.2 输出迭代器
介绍输出迭代器的定义和使用。

##### 4.2.2.3 前向迭代器
提供前向迭代器的定义和使用示例。

##### 4.2.2.4 双向迭代器
讲解双向迭代器的定义和使用。

##### 4.2.2.5 随机访问迭代器
介绍随机访问迭代器的定义和使用。

#### 4.2.3 迭代器的操作

##### 4.2.3.1 迭代器的初始化
讲解迭代器的初始化方法和示例。

##### 4.2.3.2 迭代器的移动
介绍迭代器的移动操作和使用示例。

##### 4.2.3.3 迭代器的比较
提供迭代器的比较操作和使用示例。

### 4.3 算法

#### 4.3.1 常用算法

##### 4.3.1.1 排序算法
介绍常用排序算法及其使用。

##### 4.3.1.2 查找算法
讲解常用查找算法及其使用。

##### 4.3.1.3 变换算法
提供常用变换算法及其使用示例。

#### 4.3.2 算法的使用

##### 4.3.2.1 sort
介绍 sort 算法的定义和使用。

##### 4.3.2.2 find
讲解 find 算法的定义和使用。

##### 4.3.2.3 transform
提供 transform 算法的定义和使用示例。

### 4.4 仿函数 (functors)

#### 4.4.1 定义

##### 4.4.1.1 基本概念
介绍仿函数的基本概念和定义。

##### 4.4.1.2 示例
提供仿函数的代码示例。

#### 4.4.2 使用

##### 4.4.2.1 常见使用场景
讲解仿函数的常见使用场景和示例。

#### 4.4.3 自定义仿函数

##### 4.4.3.1 定义
介绍自定义仿函数的定义和实现。

##### 4.4.3.2 示例
提供自定义仿函数的代码示例。

### 4.5 适配器

#### 4.5.1 定义

##### 4.5.1.1 基本概念
介绍适配器的基本概念和定义。

##### 4.5.1.2 示例
提供适配器的代码示例。

#### 4.5.2 常见适配器

##### 4.5.2.1 迭代器适配器
介绍迭代器适配器的定义和使用。

##### 4.5.2.2 函数适配器
讲解函数适配器的定义和使用。

##### 4.5.2.3 容器适配器
提供容器适配器的定义和使用示例。

### 4.6 空间适配器

#### 4.6.1 定义

##### 4.6.1.1 基本概念
介绍空间适配器的基本概念和定义。

##### 4.6.1.2 示例
提供空间适配器的代码示例。

#### 4.6.2 常见空间适配器

##### 4.6.2.1 allocator
讲解 allocator 适配器的定义和使用。

##### 4.6.2.2 示例
提供 allocator 适配器的代码示例。

## 5. 高级特性

### 5.1 模板编程

#### 5.1.1 基本概念
介绍模板编程的基本概念，包括模板的定义和用途。

#### 5.1.2 函数模板

##### 5.1.2.1 定义与使用
讲解函数模板的定义和基本使用方法。

##### 5.1.2.2 示例代码
提供函数模板的代码示例和使用场景。

#### 5.1.3 类模板

##### 5.1.3.1 定义与使用
介绍类模板的定义和基本使用方法。

##### 5.1.3.2 示例代码
提供类模板的代码示例和使用场景。

#### 5.1.4 模板特化

##### 5.1.4.1 定义与使用
讲解模板特化的定义和基本使用方法。

##### 5.1.4.2 示例代码
提供模板特化的代码示例和使用场景。

### 5.2 异常处理

#### 5.2.1 基本概念
介绍异常处理的基本概念，包括异常的定义和用途。

#### 5.2.2 try-catch 语句

##### 5.2.2.1 定义与使用
讲解 try-catch 语句的定义和基本使用方法。

##### 5.2.2.2 示例代码
提供 try-catch 语句的代码示例和使用场景。

#### 5.2.3 throw 语句

##### 5.2.3.1 定义与使用
介绍 throw 语句的定义和基本使用方法。

##### 5.2.3.2 示例代码
提供 throw 语句的代码示例和使用场景。

#### 5.2.4 自定义异常

##### 5.2.4.1 定义与使用
讲解自定义异常的定义和基本使用方法。

##### 5.2.4.2 示例代码
提供自定义异常的代码示例和使用场景。

### 5.3 智能指针

#### 5.3.1 基本概念
介绍智能指针的基本概念，包括智能指针的定义和用途。

#### 5.3.2 shared_ptr

##### 5.3.2.1 定义与使用
讲解 shared_ptr 的定义和基本使用方法。

##### 5.3.2.2 示例代码
提供 shared_ptr 的代码示例和使用场景。

#### 5.3.3 unique_ptr

##### 5.3.3.1 定义与使用
介绍 unique_ptr 的定义和基本使用方法。

##### 5.3.3.2 示例代码
提供 unique_ptr 的代码示例和使用场景。

#### 5.3.4 weak_ptr

##### 5.3.4.1 定义与使用
讲解 weak_ptr 的定义和基本使用方法。

##### 5.3.4.2 示例代码
提供 weak_ptr 的代码示例和使用场景。

### 5.4 多线程

#### 5.4.1 基本概念
介绍多线程的基本概念，包括多线程的定义和用途。

#### 5.4.2 线程的创建与管理

##### 5.4.2.1 定义与使用
讲解线程的创建与管理的基本方法。

##### 5.4.2.2 示例代码
提供线程创建与管理的代码示例和使用场景。

#### 5.4.3 线程同步

##### 5.4.3.1 基本概念
介绍线程同步的基本概念和用途。

##### 5.4.3.2 mutex

###### 5.4.3.2.1 定义与使用
讲解 mutex 的定义和基本使用方法。

###### 5.4.3.2.2 示例代码
提供 mutex 的代码示例和使用场景。

##### 5.4.3.3 lock_guard

###### 5.4.3.3.1 定义与使用
介绍 lock_guard 的定义和基本使用方法。

###### 5.4.3.3.2 示例代码
提供 lock_guard 的代码示例和使用场景。

##### 5.4.3.4 condition_variable

###### 5.4.3.4.1 定义与使用
讲解 condition_variable 的定义和基本使用方法。

###### 5.4.3.4.2 示例代码
提供 condition_variable 的代码示例和使用场景。

### 5.5 标准库 (Standard Library)

#### 5.5.1 I/O 库

##### 5.5.1.1 基本概念
介绍 I/O 库的基本概念和用途。

##### 5.5.1.2 cin, cout, cerr

###### 5.5.1.2.1 定义与使用
讲解 cin, cout, cerr 的定义和基本使用方法。

###### 5.5.1.2.2 示例代码
提供 cin, cout, cerr 的代码示例和使用场景。

##### 5.5.1.3 文件 I/O

###### 5.5.1.3.1 定义与使用
介绍文件 I/O 的定义和基本使用方法。

###### 5.5.1.3.2 示例代码
提供文件 I/O 的代码示例和使用场景。

#### 5.5.2 字符串处理

##### 5.5.2.1 string 类

###### 5.5.2.1.1 定义与使用
讲解 string 类的定义和基本使用方法。

###### 5.5.2.1.2 示例代码
提供 string 类的代码示例和使用场景。

##### 5.5.2.2 常用字符串操作函数

###### 5.5.2.2.1 定义与使用
介绍常用字符串操作函数的定义和基本使用方法。

###### 5.5.2.2.2 示例代码
提供常用字符串操作函数的代码示例和使用场景。

#### 5.5.3 日期和时间

##### 5.5.3.1 chrono 库

###### 5.5.3.1.1 定义与使用
讲解 chrono 库的定义和基本使用方法。

###### 5.5.3.1.2 示例代码
提供 chrono 库的代码示例和使用场景。

##### 5.5.3.2 时间的获取与格式化

###### 5.5.3.2.1 定义与使用
介绍时间的获取与格式化的定义和基本使用方法。

###### 5.5.3.2.2 示例代码
提供时间获取与格式化的代码示例和使用场景。

## 6. 设计模式

### 6.1 单例模式

#### 6.1.1 基本概念
介绍单例模式的基本概念，包括其定义、用途和优缺点。

#### 6.1.2 实现方法

##### 6.1.2.1 饿汉式
详细讲解饿汉式单例模式的实现方法及其特点。

##### 6.1.2.2 懒汉式
详细讲解懒汉式单例模式的实现方法及其特点。

##### 6.1.2.3 双重检查锁
详细讲解双重检查锁单例模式的实现方法及其特点。

#### 6.1.3 示例代码
提供单例模式的具体代码示例。

#### 6.1.4 单例模式的应用场景
介绍单例模式的常见应用场景及其适用性。

### 6.2 工厂模式

#### 6.2.1 基本概念
介绍工厂模式的基本概念，包括其定义、用途和优缺点。

#### 6.2.2 实现方法

##### 6.2.2.1 简单工厂
详细讲解简单工厂模式的实现方法及其特点。

##### 6.2.2.2 工厂方法
详细讲解工厂方法模式的实现方法及其特点。

##### 6.2.2.3 抽象工厂
详细讲解抽象工厂模式的实现方法及其特点。

#### 6.2.3 示例代码
提供工厂模式的具体代码示例。

#### 6.2.4 工厂模式的应用场景
介绍工厂模式的常见应用场景及其适用性。

### 6.3 观察者模式

#### 6.3.1 基本概念
介绍观察者模式的基本概念，包括其定义、用途和优缺点。

#### 6.3.2 实现方法

##### 6.3.2.1 传统实现
详细讲解传统观察者模式的实现方法及其特点。

##### 6.3.2.2 使用 STL
详细讲解使用 STL 容器实现观察者模式的方法及其特点。

#### 6.3.3 示例代码
提供观察者模式的具体代码示例。

#### 6.3.4 观察者模式的应用场景
介绍观察者模式的常见应用场景及其适用性。

### 6.4 访问者模式

#### 6.4.1 基本概念
介绍访问者模式的基本概念，包括其定义、用途和优缺点。

#### 6.4.2 实现方法

##### 6.4.2.1 传统实现
详细讲解传统访问者模式的实现方法及其特点。

##### 6.4.2.2 使用 STL
详细讲解使用 STL 容器实现访问者模式的方法及其特点。

#### 6.4.3 示例代码
提供访问者模式的具体代码示例。

#### 6.4.4 访问者模式的应用场景
介绍访问者模式的常见应用场景及其适用性。

## 7. 实践问题及解答

### 7.1 常见编译错误

#### 7.1.1 语法错误
- 常见的语法错误及其原因
- 如何定位和修复语法错误
- 示例代码与解决方案

#### 7.1.2 链接错误
- 常见的链接错误及其原因
- 如何定位和修复链接错误
- 示例代码与解决方案

#### 7.1.3 运行时错误
- 常见的运行时错误及其原因
- 如何定位和修复运行时错误
- 示例代码与解决方案

### 7.2 内存管理问题

#### 7.2.1 内存泄漏
- 内存泄漏的定义与原因
- 如何检测和修复内存泄漏
- 示例代码与解决方案

#### 7.2.2 悬挂指针
- 悬挂指针的定义与原因
- 如何避免和解决悬挂指针
- 示例代码与解决方案

#### 7.2.3 缓冲区溢出
- 缓冲区溢出的定义与原因
- 如何检测和防止缓冲区溢出
- 示例代码与解决方案

### 7.3 性能优化

#### 7.3.1 编译器优化
- 常见的编译器优化选项
- 如何使用编译器优化提高性能
- 示例代码与优化效果

#### 7.3.2 代码优化
- 代码优化的原则与方法
- 如何编写高效的代码
- 示例代码与优化效果

#### 7.3.3 数据结构选择
- 不同数据结构的性能特点
- 如何选择合适的数据结构
- 示例代码与性能比较

### 7.4 代码风格和最佳实践

#### 7.4.1 命名规范
- 变量、函数、类等的命名规范
- 如何编写易读的代码
- 示例代码与命名规范

#### 7.4.2 注释规范
- 注释的原则与方法
- 如何编写有用的注释
- 示例代码与注释规范

#### 7.4.3 代码格式化
- 代码格式化的重要性
- 常用的代码格式化工具和方法
- 示例代码与格式化前后对比

#### 7.4.4 重构
- 代码重构的原则与方法
- 常见的重构技巧和案例
- 示例代码与重构前后对比

## 8. C++11, 14, 17, 20 等新特性

### 8.1 C++11 新特性

#### 8.1.1 auto 关键字
- auto 关键字的基本概念
- auto 的使用场景
- 示例代码

#### 8.1.2 lambda 表达式
- lambda 表达式的基本概念
- lambda 表达式的语法
- lambda 表达式的使用场景
- 示例代码

#### 8.1.3 智能指针
- 智能指针的基本概念
- std::shared_ptr, std::unique_ptr, std::weak_ptr
- 示例代码

#### 8.1.4 右值引用和移动语义
- 右值引用的基本概念
- 移动构造函数与移动赋值运算符
- 示例代码

#### 8.1.5 其他新特性
- nullptr
- 静态断言 (static_assert)
- range-based for 循环
- std::array, std::tuple
- 示例代码

### 8.2 C++14 新特性

#### 8.2.1 lambda 表达式的增强
- lambda 表达式参数的自动推导
- 示例代码

#### 8.2.2 std::make_unique
- std::make_unique 的基本概念
- std::make_unique 的使用
- 示例代码

#### 8.2.3 二进制字面值
- 二进制字面值的基本概念
- 示例代码

#### 8.2.4 其他新特性
- 变量模板
- 泛型 lambda 表达式
- 返回类型推导
- 示例代码

### 8.3 C++17 新特性

#### 8.3.1 std::optional
- std::optional 的基本概念
- std::optional 的使用
- 示例代码

#### 8.3.2 std::variant
- std::variant 的基本概念
- std::variant 的使用
- 示例代码

#### 8.3.3 std::any
- std::any 的基本概念
- std::any 的使用
- 示例代码

#### 8.3.4 结构化绑定
- 结构化绑定的基本概念
- 结构化绑定的使用
- 示例代码

#### 8.3.5 if constexpr
- if constexpr 的基本概念
- if constexpr 的使用
- 示例代码

#### 8.3.6 其他新特性
- 文件系统库 (std::filesystem)
- 并行算法
- 内联变量 (inline variables)
- 示例代码

### 8.4 C++20 新特性

#### 8.4.1 模块 (Modules)
- 模块的基本概念
- 模块的定义与导入
- 模块的优势
- 示例代码

#### 8.4.2 协程 (Coroutines)
- 协程的基本概念
- 协程的语法与使用
- 协程的优势
- 示例代码

#### 8.4.3 范围 (Ranges)
- 范围库的基本概念
- 范围的使用与操作
- 示例代码

#### 8.4.4 概念 (Concepts)
- 概念的基本概念
- 概念的定义与使用
- 示例代码

#### 8.4.5 三路比较运算符 (<=>)
- 三路比较运算符的基本概念
- 三路比较运算符的使用
- 示例代码

#### 8.4.6 日志库 (std::format)
- 日志库的基本概念
- std::format 的使用
- 示例代码

#### 8.4.7 其他改进
- constinit 关键字
- 扩展的 constexpr
- 新的标准属性 [[likely]] 和 [[unlikely]]
- 示例代码

## 9. 项目和练习

### 9.1 小型项目

#### 9.1.1 学生成绩管理系统
- 项目简介
- 项目需求分析
- 项目设计
  - 类的设计
  - 数据结构的设计
- 代码实现
  - 主程序
  - 类定义与实现
- 测试与调试

#### 9.1.2 图书管理系统
- 项目简介
- 项目需求分析
- 项目设计
  - 类的设计
  - 数据结构的设计
- 代码实现
  - 主程序
  - 类定义与实现
- 测试与调试

### 9.2 代码挑战和练习题

#### 9.2.1 挑战1：排序算法的实现
- 题目描述
- 解题思路
- 代码实现
- 测试用例

#### 9.2.2 挑战2：数据结构的实现
- 题目描述
- 解题思路
- 代码实现
- 测试用例

### 9.3 实践项目

#### 9.3.1 简易Web服务器
- 项目简介
- 项目需求分析
- 项目设计
  - 类的设计
  - 数据结构的设计
- 代码实现
  - 主程序
  - 类定义与实现
- 测试与调试

#### 9.3.2 聊天应用程序
- 项目简介
- 项目需求分析
- 项目设计
  - 类的设计
  - 数据结构的设计
- 代码实现
  - 主程序
  - 类定义与实现
- 测试与调试

### 9.4 其他练习题

#### 9.4.1 练习题1
- 题目描述
- 解题思路
- 代码实现
- 测试用例

#### 9.4.2 练习题2
- 题目描述
- 解题思路
- 代码实现
- 测试用例

### 9.5 项目心得和总结
- 项目回顾
- 学习心得
- 改进建议
- 未来规划

## 10. 参考资料

### 10.1 书籍推荐

#### 10.1.1 《C++ Primer》
- 作者
- 内容简介
- 适用读者
- 书籍亮点
- 获取方式

#### 10.1.2 《Effective C++》
- 作者
- 内容简介
- 适用读者
- 书籍亮点
- 获取方式

#### 10.1.3 《The C++ Programming Language》
- 作者
- 内容简介
- 适用读者
- 书籍亮点
- 获取方式

#### 10.1.4 其他推荐书籍
- 《More Effective C++》
- 《C++ Concurrency in Action》
- 《Modern C++ Design》
- 其他书籍推荐

### 10.2 在线资源

#### 10.2.1 C++ 官方文档
- 链接
- 使用指南
- 文档亮点

#### 10.2.2 C++ 教程网站
- 链接
- 网站简介
- 适用读者
- 网站亮点

#### 10.2.3 C++ 社区论坛
- 链接
- 社区简介
- 讨论话题
- 参与方式

### 10.3 常用库和框架

#### 10.3.1 Boost
- 简介
- 功能模块
- 安装与配置
- 示例代码

#### 10.3.2 Qt
- 简介
- 功能模块
- 安装与配置
- 示例代码

#### 10.3.3 POCO
- 简介
- 功能模块
- 安装与配置
- 示例代码

#### 10.3.4 其他常用库
- OpenCV
- CppUnit
- 其他库推荐

### 10.4 常见问题与解答

#### 10.4.1 编译错误
- 常见错误类型
- 错误原因分析
- 解决方法

#### 10.4.2 链接错误
- 常见错误类型
- 错误原因分析
- 解决方法

#### 10.4.3 运行时错误
- 常见错误类型
- 错误原因分析
- 解决方法

### 10.5 代码风格和最佳实践

#### 10.5.1 命名规范
- 变量命名
- 函数命名
- 类命名
- 命名示例

#### 10.5.2 注释规范
- 单行注释
- 多行注释
- 函数注释
- 类注释
- 注释示例

#### 10.5.3 代码格式化
- 缩进和对齐
- 空格和换行
- 代码格式化工具

#### 10.5.4 重构
- 重构的基本概念
- 重构的常见方法
- 重构示例

### 10.6 学习心得和建议
- 学习C++的心路历程
- 高效学习方法
- 常见误区
- 学习资源推荐
- 未来规划
