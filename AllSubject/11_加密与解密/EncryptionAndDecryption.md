## 基础篇
### 第1章 基础知识
#### 1.1 什么是加密与解密
##### 1.1.1 软件的加密与解密
##### 1.1.2 软件逆向工程
##### 1.1.3 逆向分析技术
#### 1.2 文本字符
##### 1.2.1 ASCII与Unicode字符集
##### 1.2.2 字节存储顺序
#### 1.3 Windows操作系统
##### 1.3.1 Win32 API函数
##### 1.3.2 WOW64
##### 1.3.3 Windows消息机制
##### 1.3.4 虚拟内存

## 调试篇
### 第2章 动态分析技术
#### 2.1 OllyDbg调试器
##### 2.1.1 OllyDbg的界面
##### 2.1.2 OllyDbg的配置
##### 2.1.3 基本操作
##### 2.1.4 常用断点
##### 2.1.5 插件
##### 2.1.6 Run trace
##### 2.1.7 Hit trace
##### 2.1.8 调试符号
##### 2.1.9 加载程序
##### 2.1.10 OllyDbg的常见问题
#### 2.2 x64dbg调试器
#### 2.3 MDebug调试器
##### 2.3.1 MDebug的界面
##### 2.3.2 表达式
##### 2.3.3 调试
##### 2.3.4 断点
##### 2.3.5 MDebug的其他功能
#### 2.4 WinDbg调试器
##### 2.4.1 WinDbg的安装与配置
##### 2.4.2 调试过程
##### 2.4.3 断点命令
##### 2.4.4 栈窗口
##### 2.4.5 内存命令
##### 2.4.6 脚本
##### 2.4.7 调试功能扩展
##### 2.4.8 小结

### 第3章 静态分析技术
#### 3.1 文件类型分析
#### 3.2 反汇编引擎
##### 3.2.1 OllyDbg的ODDisasm
##### 3.2.2 BeaEngine
##### 3.2.3 Udis86
##### 3.2.4 Capstone
##### 3.2.5 AsmJit
##### 3.2.6 Keystone
##### 3.2.7 小结
#### 3.3 静态反汇编
##### 3.3.1 IDA Pro简介
##### 3.3.2 IDA的配置
##### 3.3.3 IDA主窗口
##### 3.3.4 交叉参考
##### 3.3.5 参考重命名
##### 3.3.6 标签的用法
##### 3.3.7 格式化指令操作数
##### 3.3.8 函数的操作
##### 3.3.9 代码和数据转换
##### 3.3.10 字符串
##### 3.3.11 数组
##### 3.3.12 结构体
##### 3.3.13 枚举类型
##### 3.3.14 变量
##### 3.3.15 FLIRT
##### 3.3.16 IDC脚本
##### 3.3.17 插件
##### 3.3.18 IDA调试器
##### 3.3.19 远程调试
##### 3.3.20 其他功能
##### 3.3.21 小结
#### 3.4 十六进制工具
#### 3.5 静态分析技术应用实例
##### 3.5.1 解密初步
##### 3.5.2 逆向工程初步

## 解密篇
### 第4章 逆向分析技术
#### 4.1 32位软件逆向技术
##### 4.1.1 启动函数
##### 4.1.2 函数
##### 4.1.3 数据结构
##### 4.1.4 虚函数
##### 4.1.5 控制语句
##### 4.1.6 循环语句
##### 4.1.7 数学运算符
##### 4.1.8 文本字符串
##### 4.1.9 指令修改技巧
#### 4.2 64位软件逆向技术
##### 4.2.1 寄存器
##### 4.2.2 函数
##### 4.2.3 数据结构
##### 4.2.4 控制语句
##### 4.2.5 循环语句
##### 4.2.6 数学运算符
##### 4.2.7 虚函数
##### 4.2.8 小结

### 第5章 演示版保护技术
#### 5.1 序列号保护方式
##### 5.1.1 序列号保护机制
##### 5.1.2 如何攻击序列号保护机制
##### 5.1.3 字符串比较形式
##### 5.1.4 制作注册机
#### 5.2 警告窗口
#### 5.3 时间限制
##### 5.3.1 计时器
##### 5.3.2 时间限制
##### 5.3.3 拆解时间限制保护
#### 5.4 菜单功能限制
##### 5.4.1 相关函数
##### 5.4.2 拆解菜单限制保护
#### 5.5 KeyFile保护
##### 5.5.1 相关API函数
##### 5.5.2 拆解KeyFile保护
#### 5.6 网络验证
##### 5.6.1 相关函数
##### 5.6.2 破解网络验证的一般思路
#### 5.7 光盘检测
##### 5.7.1 相关函数
##### 5.7.2 拆解光盘保护
#### 5.8 只运行1个实例
##### 5.8.1 实现方法
##### 5.8.2 实例
#### 5.9 常用断点设置技巧

### 第6章 加密算法
#### 6.1 单向散列算法
##### 6.1.1 MD5算法
##### 6.1.2 SHA算法
##### 6.1.3 SM3密码杂凑算法
##### 6.1.4 小结
#### 6.2 对称加密算法
##### 6.2.1 RC4流密码
##### 6.2.2 TEA算法
##### 6.2.3 IDEA算法
##### 6.2.4 BlowFish算法
##### 6.2.5 AES算法
##### 6.2.6 SM4分组密码算法
##### 6.2.7 小结
#### 6.3 公开密钥加密算法
##### 6.3.1 RSA算法
##### 6.3.2 ElGamal公钥算法
##### 6.3.3 DSA数字签名算法
##### 6.3.4 椭圆曲线密码编码学
##### 6.3.5 SM2算法
#### 6.4 其他算法
##### 6.4.1 CRC32算法
##### 6.4.2 Base64编码
#### 6.5 常见的加密库接口及其识别
##### 6.5.1 Miracl大数运算库
##### 6.5.2 FGInt
##### 6.5.3 其他加密算法库介绍
#### 6.6 加密算法在软件保护中的应用

## 系统篇
### 第7章 Windows内核基础
#### 7.1 内核理论基础
##### 7.1.1 权限级别
##### 7.1.2 内存空间布局
##### 7.1.3 Windows与内核启动过程
##### 7.1.4 Windows R3与R0通信
##### 7.1.5 内核函数
##### 7.1.6 内核驱动模块
#### 7.2 内核重要数据结构
##### 7.2.1 内核对象
##### 7.2.2 SSDT
##### 7.2.3 TEB
##### 7.2.4 PEB
#### 7.3 内核调试基础
##### 7.3.1 使用WinDbg搭建双机调试环境
##### 7.3.2 加载内核驱动并设置符号表
##### 7.3.3 SSDT与Shadow SSDT的查看

### 第8章 Windows下的异常处理
#### 8.1 异常处理的基本概念
##### 8.1.1 异常列表
##### 8.1.2 异常处理的基本过程
#### 8.2 SEH的概念及基本知识
##### 8.2.1 SEH的相关数据结构
##### 8.2.2 SEH处理程序的安装和卸载
##### 8.2.3 SEH实例跟踪
#### 8.3 SEH异常处理程序原理及设计
##### 8.3.1 异常分发的详细过程
##### 8.3.2 线程异常处理
##### 8.3.3 异常处理的栈展开
##### 8.3.4 MSC编译器对线程异常处理的增强
##### 8.3.5 顶层异常处理
##### 8.3.6 异常处理程序的安全性
#### 8.4 向量化异常处理
##### 8.4.1 向量化异常处理的使用
##### 8.4.2 VEH与SEH的异同
##### 8.4.3 向量化异常处理的新内容
#### 8.5 x64平台上的异常处理
##### 8.5.1 原生x64程序的异常分发
##### 8.5.2 WOW64下的异常分发
#### 8.6 异常处理程序设计中的注意事项
#### 8.7 异常处理的实际应用
##### 8.7.1 使用SEH对用户输入进行验证
##### 8.7.2 SEH在加密与解密中的应用
##### 8.7.3 用VEH实现API Hook
#### 8.8 本章小结

### 第9章 Win32调试API
#### 9.1 调试相关函数简要说明
#### 9.2 调试事件
#### 9.3 创建并跟踪进程
#### 9.4 调试循环体
#### 9.5 处理调试事件
#### 9.6 线程环境
#### 9.7 将代码注入进程

### 第10章 VT技术
#### 10.1 硬件虚拟化的基本概念
##### 10.1.1 概述
##### 10.1.2 相关结构和汇编指令
##### 10.1.3 EPT机制
#### 10.2 VT技术的应用
##### 10.2.1 编译运行ShadowWalker
##### 10.2.2 分析Hypervisor
##### 10.2.3 检测VT支持情况
##### 10.2.4 VMCS的配置
##### 10.2.5 EPT的配置
##### 10.2.6 开启VT
##### 10.2.7 内存隐藏的实现
#### 10.3 VT调试方法

### 第11章 PE文件格式
#### 11.1 PE的基本概念
##### 11.1.1 基地址
##### 11.1.2 虚拟地址
##### 11.1.3 相对虚拟地址
##### 11.1.4 文件偏移地址
#### 11.2 MS-DOS头部
#### 11.3 PE文件头
##### 11.3.1 Signature字段
##### 11.3.2 IMAGE_FILE_HEADER结构
##### 11.3.3 IMAGE_OPTIONAL_HEADER结构
#### 11.4 区块
##### 11.4.1 区块表
##### 11.4.2 常见区块与区块合并
##### 11.4.3 区块的对齐值
##### 11.4.4 文件偏移与虚拟地址的转换
#### 11.5 输入表
##### 11.5.1 输入函数的调用
##### 11.5.2 输入表的结构
##### 11.5.3 输入地址表
##### 11.5.4 输入表实例分析
#### 11.6 绑定输入
#### 11.7 输出表
##### 11.7.1 输出表的结构
##### 11.7.2 输出表实例分析
#### 11.8 基址重定位
##### 11.8.1 基址重定位的概念
##### 11.8.2 基址重定位表的结构
##### 11.8.3 基址重定位表实例分析
#### 11.9 资源
##### 11.9.1 资源结构
##### 11.9.2 资源结构实例分析
##### 11.9.3 资源编辑工具
#### 11.10 TLS初始化
#### 11.11 调试目录
#### 11.12 延迟载入数据
#### 11.13 程序异常数据
#### 11.14 .NET头部
#### 11.15 编写PE分析工具
##### 11.15.1 检查文件格式
##### 11.15.2 读取FileHeader和OptionalHeader的内容
##### 11.15.3 得到数据目录表信息
##### 11.15.4 得到区块表信息
##### 11.15.5 得到输出表信息
##### 11.15.6 得到输入表信息

### 第12章 注入技术
#### 12.1 DLL注入方法
##### 12.1.1 通过干预输入表处理过程加载目标DLL
##### 12.1.2 改变程序运行流程使其主动加载目标DLL
##### 12.1.3 利用系统机制加载DLL
#### 12.2 DLL注入的应用
#### 12.3 DLL注入的防范
##### 12.3.1 驱动层防范
##### 12.3.2 应用层防范

### 第13章 Hook技术
#### 13.1 Hook概述
##### 13.1.1 IAT Hook篡改MessageBox消息
##### 13.1.2 Inline Hook篡改指定MessageBox消息
#### 13.2 Hook的分类
##### 13.2.1 Address Hook
##### 13.2.2 Inline Hook
##### 13.2.3 基于异常处理的Hook
##### 13.2.4 不是Hook的Hook
#### 13.3 Hook位置的挑选
#### 13.4 Hook的典型过程
##### 13.4.1 Address Hook的实施过程
##### 13.4.2 Inline Hook的实施过程
##### 13.4.3 基于异常处理的Hook实施过程
##### 13.4.4 二次Hook的注意事项
##### 13.4.5 通用Hook引擎的实现
#### 13.5 Detour函数的典型用法
#### 13.6 Hook中的注意事项
#### 13.7 Hook在x64平台上的新问题
#### 13.8 Hook技术的应用
#### 13.9 Hook的检测、恢复与对抗
##### 13.9.1 Hook的检测与恢复
##### 13.9.2 Hook的对抗
#### 13.10 本章小结

## 漏洞篇
### 第14章 漏洞分析技术
#### 14.1 软件漏洞原理
##### 14.1.1 缓冲区溢出漏洞
##### 14.1.2 整型溢出漏洞
##### 14.1.3 UAF漏洞
#### 14.2 Shellcode
##### 14.2.1 Shellcode的结构
##### 14.2.2 Shellcode通用技术
##### 14.2.3 实战Shellcode编写
#### 14.3 漏洞利用
##### 14.3.1 漏洞利用基本技术
##### 14.3.2 漏洞利用高级技术
#### 14.4 漏洞样本
#### 14.5 样本分析
##### 14.5.1 准备工作
##### 14.5.2 静态分析
##### 14.5.3 动态调试
##### 14.5.4 追根溯源
##### 14.5.5 小结

## 脱壳篇
### 第15章 专用加密软件
#### 15.1 认识壳
##### 15.1.1 壳的概念
##### 15.1.2 压缩引擎
#### 15.2 压缩壳
##### 15.2.1 UPX
##### 15.2.2 ASPack
#### 15.3 加密壳
##### 15.3.1 ASProtect
##### 15.3.2 Armadillo
##### 15.3.3 EXECryptor
##### 15.3.4 Themida
#### 15.4 虚拟机保护软件
##### 15.4.1 虚拟机介绍
##### 15.4.2 VMProtect简介

### 第16章 脱壳技术
#### 16.1 基础知识
##### 16.1.1 壳的加载过程
##### 16.1.2 脱壳机
##### 16.1.3 手动脱壳
#### 16.2 寻找OEP
##### 16.2.1 根据跨段指令寻找OEP
##### 16.2.2 用内存访问断点寻找OEP
##### 16.2.3 根据栈平衡原理寻找OEP
##### 16.2.4 根据编译语言特点寻找OEP
#### 16.3 抓取内存映像
##### 16.3.1 Dump原理
##### 16.3.2 反Dump技术
#### 16.4 重建输入表
##### 16.4.1 输入表重建的原理
##### 16.4.2 确定IAT的地址和大小
##### 16.4.3 根据IAT重建输入表
##### 16.4.4 用Import REC重建输入表
##### 16.4.5 输入表加密概括
#### 16.5 DLL文件脱壳
##### 16.5.1 寻找OEP
##### 16.5.2 Dump映像文件
##### 16.5.3 重建DLL的输入表
##### 16.5.4 构造重定位表
#### 16.6 附加数据
#### 16.7 PE文件的优化
#### 16.8 压缩壳
##### 16.8.1 UPX外壳
##### 16.8.2 ASPack外壳
#### 16.9 加密壳
#### 16.10 静态脱壳
##### 16.10.1 外壳Loader分析
##### 16.10.2 编写静态脱壳器

## 保护篇
### 第17章 软件保护技术
#### 17.1 防范算法求逆
##### 17.1.1 基本概念
##### 17.1.2 堡垒战术
##### 17.1.3 游击战术
#### 17.2 抵御静态分析
##### 17.2.1 花指令
##### 17.2.2 SMC技术实现
##### 17.2.3 信息隐藏
##### 17.2.4 简单的多态变形技术
#### 17.3 文件完整性检验
##### 17.3.1 磁盘文件校验的实现
##### 17.3.2 校验和
##### 17.3.3 内存映像校验
#### 17.4 代码与数据结合
##### 17.4.1 准备工作
##### 17.4.2 加密算法的选用
##### 17.4.3 手动加密代码
##### 17.4.4 使 .text区块可写
#### 17.5 关于软件保护的若干忠告

### 第18章 反跟踪技术
#### 18.1 由BeingDebugged引发的蝴蝶效应
##### 18.1.1 BeingDebugged
##### 18.1.2 NtGlobalFlag
##### 18.1.3 Heap Magic
##### 18.1.4 从源头消灭BeingDebugged
#### 18.2 回归Native：用户态的梦魇
##### 18.2.1 CheckRemoteDebuggerPresent
##### 18.2.2 ProcessDebugPort
##### 18.2.3 ThreadHideFromDebugger
##### 18.2.4 DebugObject
##### 18.2.5 SystemKernelDebuggerInformation
##### 18.2.6 Native API
##### 18.2.7 Hook和AntiHook
#### 18.3 真正的奥秘：小技巧一览
##### 18.3.1 SoftICE检测方法
##### 18.3.2 OllyDbg检测方法
##### 18.3.3 调试器漏洞
##### 18.3.4 防止调试器附加
##### 18.3.5 父进程检测
##### 18.3.6 时间差
##### 18.3.7 通过Trap Flag检测
##### 18.3.8 双进程保护

### 第19章 外壳编写基础
#### 19.1 外壳的结构
#### 19.2 加壳主程序
##### 19.2.1 判断文件是否为PE格式
##### 19.2.2 文件基本数据读入
##### 19.2.3 附加数据的读取
##### 19.2.4 输入表的处理
##### 19.2.5 重定位表的处理
##### 19.2.6 文件的压缩
##### 19.2.7 资源数据的处理
##### 19.2.8 区块的融合
#### 19.3 用汇编写外壳部分
##### 19.3.1 外壳的加载过程
##### 19.3.2 自建输入表
##### 19.3.3 外壳引导段
##### 19.3.4 外壳第2部分
##### 19.3.5 将外壳部分添加至原程序
#### 19.4 用C++编写外壳部分

### 第20章 虚拟机的设计
#### 20.1 虚拟机保护技术原理
##### 20.1.1 反汇编引擎
##### 20.1.2 指令分类
#### 20.2 启动框架和调用约定
##### 20.2.1 调度器
##### 20.2.2 虚拟环境
##### 20.2.3 平衡栈vBegin和vCheckESP
#### 20.3 Handler的设计
##### 20.3.1 辅助Handler
##### 20.3.2 普通Handler和指令拆解
##### 20.3.3 标志位问题
##### 20.3.4 相同作用的指令
##### 20.3.5 转移指令
##### 20.3.6 转移跳转指令的另一种实现
##### 20.3.7 call指令
##### 20.3.8 retn指令
##### 20.3.9 不可模拟指令
#### 20.4 托管代码的异常处理
##### 20.4.1 VC++的异常处理
##### 20.4.2 Delphi的异常处理
#### 20.5 本章小结

### 第21章 VMProtect逆向和还原浅析
#### 21.1 VMProtect逆向分析
##### 21.1.1 VMProtect虚拟执行引擎的全景图
##### 21.1.2 VMProtect虚拟引擎的基本架构
##### 21.1.3 指令分类
#### 21.2 VMProtect的还原
##### 21.2.1 虚拟执行系统
##### 21.2.2 生成完整的字节码流程图
##### 21.2.3 给Handler命名并添加语义动作
##### 21.2.4 将字节码的低级描述转换为中级描述
##### 21.2.5 清除无用的字节码
##### 21.2.6 用真值表化简逻辑指令
##### 21.2.7 从特征中建立部分寄存器映射信息
##### 21.2.8 其他无法确定的寄存器的图着色算法
##### 21.2.9 使用DAG匹配生成指令
##### 21.2.10 其他问题

## 软件重构篇
### 第22章 补丁技术
#### 22.1 文件补丁
#### 22.2 内存补丁
##### 22.2.1 跨进程内存存取机制
##### 22.2.2 Debug API机制
##### 22.2.3 利用调试寄存器机制
##### 22.2.4 利用DLL注入技术
##### 22.2.5 利用Hook技术
##### 22.2.6 利用VT技术
#### 22.3 SMC补丁技术
##### 22.3.1 单层SMC补丁技术
##### 22.3.2 多层SMC补丁技术
#### 22.4 补丁工具

### 第23章 代码的二次开发
#### 23.1 数据对齐
#### 23.2 增加空间
##### 23.2.1 区块间隙
##### 23.2.2 手动构造区块
##### 23.2.3 工具辅助构造区块
#### 23.3 获得函数的调用信息
##### 23.3.1 增加输入函数
##### 23.3.2 显式链接调用DLL
#### 23.4 代码的重定位
##### 23.4.1 修复重定位表
##### 23.4.2 代码的自定位技术
#### 23.5 增加输出函数
#### 23.6 消息循环
##### 23.6.1 WndProc函数
##### 23.6.2 寻找消息循环
##### 23.6.3 WndProc汇编形式
#### 23.7 菜单扩展
##### 23.7.1 扩充WndProc
##### 23.7.2 扩充Exit菜单的功能
##### 23.7.3 扩充Open菜单的功能
#### 23.8 DLL扩展
##### 23.8.1 扩展接口
##### 23.8.2 扩展消息循环

## 语言和平台篇
### 第24章 .NET平台加解密
#### 24.1 .NET概述
##### 24.1.1 什么是 .NET
##### 24.1.2 基本概念
##### 24.1.3 第1个 .NET程序
#### 24.2 MSIL与元数据
##### 24.2.1 PE结构的扩展
##### 24.2.2 .NET下的汇编MSIL
##### 24.2.3 MSIL与元数据的结合
#### 24.3 代码分析与修改技术
##### 24.3.1 静态分析
##### 24.3.2 动态调试
##### 24.3.3 代码修改
#### 24.4 .NET代码保护技术及其逆向
##### 24.4.1 强名称
##### 24.4.2 名称混淆
##### 24.4.3 流程混淆
##### 24.4.4 压缩
##### 24.4.5 加密
##### 24.4.6 其他保护手段
#### 24.5 本章小结

## 取证篇
### 第25章 数据取证技术
#### 25.1 硬盘数据的获取和固定
##### 25.1.1 硬盘数据的获取
##### 25.1.2 电子数据的固定
#### 25.2 硬盘的分区和数据恢复
##### 25.2.1 分区的解析
##### 25.2.2 基于文件系统的数据恢复原理
#### 25.3 内存分析
##### 25.3.1 内存镜像的获取
##### 25.3.2 内存镜像的分析
#### 25.4 动态仿真技术
##### 25.4.1 仿真专用硬件
##### 25.4.2 软件仿真
#### 25.5 注册表
##### 25.5.1 Hive文件
##### 25.5.2 注册表中的时间
##### 25.5.3 USB移动存储设备
#### 25.6 文件格式
##### 25.6.1 文件修复和特征码
##### 25.6.2 基于文件的数据恢复技术
##### 25.6.3 数据隐藏的分析

## 术语表
## 参考文献