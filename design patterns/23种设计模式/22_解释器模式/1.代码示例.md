### 22、解释器模式（20240606）
- 解释器模式（Interpreter Pattern）是一种行为型设计模式，用于定义语言的文法表示，并构建一个解释器来解释语言中句子。解释器模式常用于需要解释和执行语言的系统，例如脚本语言、数据库查询语言等。

**解释器模式的类图**
- **AbstractExpression**：抽象表达式，定义解释操作。
- T**erminalExpression**：终结符表达式，实现与文法中的终结符相关的解释操作。
- **NonterminalExpression**：非终结符表达式，实现与文法中的非终结符相关联的解释操作
- **Context**：包含解释器外部全部信息的类。
- **Client**：构建并解析语法书的类  
  
---

以下是不符合解释器模式的实现方式，没有使用抽象类和多态来定义解释器，所有的计算逻辑都混杂在一起，缺乏扩展性和灵活性：

**示例 1，不符合解释器模式要求的实例：**   
```C++
#include <iostream>
#include <sstream>
#include <string>
#include <stack>
#include <cctype>
#include <stdexcept>

double evaluateExpression(const std::string& expression) {
    std::istringstream tokens(expression);
    std::stack<double> values;
    std::stack<char> ops;
    std::string token;

    while (tokens >> token) {
        if (isdigit(token[0])) {
            values.push(std::stod(token));
        } else if (token == "(") {
            ops.push('(');
        } else if (token == ")") {
            while (!ops.empty() && ops.top() != '(') {
                double right = values.top(); values.pop();
                double left = values.top(); values.pop();
                char op = ops.top(); ops.pop();
                values.push(applyOp(op, left, right));
            }
            ops.pop();
        } else if (token == "+" || token == "-" || token == "*" || token == "/") {
            char currentOp = token[0];
            while (!ops.empty() && precedence(ops.top()) >= precedence(currentOp)) {
                double right = values.top(); values.pop();
                double left = values.top(); values.pop();
                char op = ops.top(); ops.pop();
                values.push(applyOp(op, left, right));
            }
            ops.push(currentOp);
        }
    }

    while (!ops.empty()) {
        double right = values.top(); values.pop();
        double left = values.top(); values.pop();
        char op = ops.top(); ops.pop();
        values.push(applyOp(op, left, right));
    }

    return values.top();
}

int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

double applyOp(char op, double a, double b) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
        default: throw std::runtime_error("Unsupported operator");
    }
}

int main() {
    std::string expression = "3 + 5 * ( 10 - 2 * ( 1 + 3 * 2 + 6 ) ) / 4 + 1";
    try {
        std::cout << "Result: " << evaluateExpression(expression) << std::endl; // Output: Incorrect or throws an exception
    } catch (const std::exception& ex) {
        std::cerr << "Exception: " << ex.what() << std::endl;
    }

    return 0;
}
```

此实现虽然能够计算简单表达式，但缺乏对复杂表达式的我们可以重新设计一个解释器模式来处理正常输入的数学表达式字符串，并实现自动处理操作符优先级和括号

---

这个实现包括一个解释器类，可以解析并计算普通数学表达式。我们将使用逆波兰表示法（后缀表达式）来确保操作符的优先级，并使用栈来进行计算。

**示例 2，符合解释器模式要求的实例：**   
```C++
#include <iostream>
#include <memory>
#include <stack>
#include <string>
#include <sstream>
#include <vector>
#include <cctype>
#include <map>
#include <stdexcept>

class Expression {
public:
    virtual double interpret(const std::map<std::string, double>& context) const = 0;
    virtual ~Expression() = 0;
};

class NumberExPression : public Expression {
private:
    double number;
public:
    NumberExpression(double number) : number(number){}
    double interpret(const std::map<std::string, double>& context) const override {
        return number;
    }
};

class VariableExpression : public Expression {
private:
    std::string name;
public:
    VariableExpression(const std::string& name) : name(name) {}
    double interpret(const std::map<std::string, double>& context) const override {
        if(context.find(name) != context.end()){
            return context.at(name);
        }
        throw std::runtime_error("Varibale not found");
    }
};

class BinaryExpression : public ExPression {
protected:
    std::shared_ptr<Expression> left, right;
public:
    BinaryExpression(std::sahred_ptr<Expression> left, std::shared_ptr<Expression> right) : left(left), right(right){}
};

class AddExpression : public BinaryExpression {
public:
    using BinaryExpression::BinaryExpression;
    double interpret(const std::map<std::string, double>& context) const override {
        return left->interpret(constext) + right->interpret(context);
    }
};

class SubtractExpression : public BinaryExpression {
public:
    using BinaryExpression::BinaryExpression;
    double interpret(const std::map<std::string, double>& context) const override {
        return left->interpret(context) - right->interpret(context);
    }
};

class MultiplyExpression : public BinaryExpression {
public:
    using BinaryExpression::BinaryExpression;
    double interpret(const std::map<std::string, double>& context) const override {
        return left->interpret(context) * right->interpret(context);
    }
};

class DivedeExpression : public BinaryExpression {
public:
    using BinaryExpression::BinaryExpression;
    double interpret(cnst std::map<std::string, double>& context) const override {
        return left->interpret(context) / right->interpret(context);
    }
};

class Evaluator {
private:
    std::shared_ptr<Expression> syntaxTree;
    std::shared_ptr<Expression> parseExpression(std::istringstream& tokens);
public:
    Evaluator(const std::string& expression) {
        std::istringstream tokenStream(tokenize(expression));
        syntaxTree = parseExpression(tokenStream);
    }

    double interpret(const std::map<std::string, double>& context) const {
        return syntaxTree->interpret(context);
    }

    std::string tokenize(const std::string& expression) {
        std::string result;
        for(char ch : expression) {
            if(isspace(ch)) continue;
            if(isdigit(ch) || ch == '.'){
                result += ch;
            }else{
                reuslt += ' ';
                result += ch;
                result += ' ';
            }
        }
        return result;
    }
};

std::shraed_ptr<Expression> Evaluator::parseExpression(std::istringstream& tokens) {
private:
    std::stack<std::shared_ptr<Expression>> values;
    std::stack<char> ops;
    std::string token;

    auto applyOps = [&](char op){
        auto right = values.top(); values.pop();
        auto left = values.top(); values.pop();
        if(op == '+') values.push(std::make_shared<AddExpression>(left, right));
        else if(op == '-') values.push(std::make_shared<SubtractExpression>(left, right));
        else if(op == '*') values.push(std::make_shard<MultiplyExpression>(left, right));
        else if(op == '/') values.push(std::make_shared<DivideExpression>(left, right));
    };

    while(tokens >> token){
        if(isdigit(token[0])){
            values.push(std::make_shared<NumberExpression>(std::stod(token)));
        }else if(token == "("){
            ops.push('(');
        }else if(token == ")"){
            while(!ops.empty() && ops.top() != '('){
                applyOps(ops.top());
                ops.pop();
            }
            ops.pop();
        }else if(token == "+" || token == "-" || token == "*" || token == "/"){
            char currentOp = token[0];
            while(!ops.empty() && precedence(ops.top()) >= precedence(currentOp)){
                applyOps(ops.top());
                ops.pop();
            }
            ops.push(currentOp);
        }
    }
    while(!ops.empty()){
        applyOps(ops.top());
        ops.pop();
    }
    return values.top();
}

int precedence(char op) {
    if(op == '+' || op == '-') return 1;
    if(op == '*' || op == '/') return 2;
    return 0;
}

int main(){
    std::string expression = "3 + 5 * ( 10 - 2 * ( 1 + 3 * 2 + 7) / 4 + 1)";
    Evaluator evaluator(expression);

    std::map<std::string, double> context;
    try {
        std::cout << "Result: "<< evaluator.interpret(context) << std::endl;
    }catch(const std::exception& ex){
        std::cerr << "Exception: " << ex.what() << std::endl;
    }

    return 0;
}
```  
**代码说明:**
- **Tokenize**：将输入的数学表达式解析成独立的标记（token），去除空格，并将数字和字符依次存入一个字符串向量tokens。
- **ParseExpression**：对tokens进行解析，使用两个栈分别存储操作数（values）和操作符（ops）。遇到操作符时，根据其优先级处理计算，确保优先级高的操作符先进性计算。
- **Interpret**：解析完成后，调用解析器树对表达式进行计算。

--- 

# **`额外的正反例1：`**
### 实际应用：简化版SQL查询解释器

我们将构建一个简化版的SQL查询解释器，用于解释和执行类似于 `SELECT` 查询的语句。这将涉及表、列选择、条件过滤等操作。

### 符合要求的解释器模式实现

#### 场景描述

我们实现一个简化的SQL查询解释器，它可以解释和执行以下格式的查询语句：

```
SELECT column FROM table WHERE condition
```

#### 代码实现

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>
#include <memory>
#include <sstream>

// 表示数据库表的简单结构
struct Table {
    std::vector<std::unordered_map<std::string, std::string>> rows;
};

// 上下文类，包含表数据
class Context {
public:
    void addTable(const std::string& name, const Table& table) {
        tables[name] = table;
    }

    const Table& getTable(const std::string& name) const {
        return tables.at(name);
    }

private:
    std::unordered_map<std::string, Table> tables;
};

// 抽象表达式类
class Expression {
public:
    virtual ~Expression() = default;
    virtual std::vector<std::unordered_map<std::string, std::string>> interpret(const Context& context) const = 0;
};

// 非终结符表达式：选择操作
class SelectExpression : public Expression {
public:
    SelectExpression(const std::string& column, std::shared_ptr<Expression> tableExpr, std::shared_ptr<Expression> conditionExpr = nullptr)
        : column(column), tableExpr(tableExpr), conditionExpr(conditionExpr) {}

    std::vector<std::unordered_map<std::string, std::string>> interpret(const Context& context) const override {
        auto rows = tableExpr->interpret(context);
        std::vector<std::unordered_map<std::string, std::string>> result;
        
        for (const auto& row : rows) {
            if (!conditionExpr || conditionExpr->interpret(context).size() > 0) {
                result.push_back({{column, row.at(column)}});
            }
        }
        
        return result;
    }

private:
    std::string column;
    std::shared_ptr<Expression> tableExpr;
    std::shared_ptr<Expression> conditionExpr;
};

// 终结符表达式：表
class TableExpression : public Expression {
public:
    TableExpression(const std::string& tableName) : tableName(tableName) {}

    std::vector<std::unordered_map<std::string, std::string>> interpret(const Context& context) const override {
        return context.getTable(tableName).rows;
    }

private:
    std::string tableName;
};

// 终结符表达式：条件
class ConditionExpression : public Expression {
public:
    ConditionExpression(const std::string& column, const std::string& value) : column(column), value(value) {}

    std::vector<std::unordered_map<std::string, std::string>> interpret(const Context& context) const override {
        std::vector<std::unordered_map<std::string, std::string>> result;

        for (const auto& row : context.getTable("users").rows) {
            if (row.at(column) == value) {
                result.push_back(row);
            }
        }

        return result;
    }

private:
    std::string column;
    std::string value;
};

// 客户端代码
int main() {
    // 创建一个简单的上下文和表数据
    Context context;
    Table users = {
        { { {"name", "Alice"}, {"age", "30"} }, { {"name", "Bob"}, {"age", "25"} }, { {"name", "Charlie"}, {"age", "35"} } }
    };
    context.addTable("users", users);

    // 解析和解释查询语句: SELECT name FROM users WHERE age = 25
    std::shared_ptr<Expression> tableExpr = std::make_shared<TableExpression>("users");
    std::shared_ptr<Expression> conditionExpr = std::make_shared<ConditionExpression>("age", "25");
    std::shared_ptr<Expression> selectExpr = std::make_shared<SelectExpression>("name", tableExpr, conditionExpr);

    auto result = selectExpr->interpret(context);

    for (const auto& row : result) {
        std::cout << "name: " << row.at("name") << std::endl;
    }

    return 0;
}
```

### 符合要求的解释

1. **抽象表达式**：`Expression` 类定义了解释操作的接口。
2. **终结符表达式**：`TableExpression` 和 `ConditionExpression` 类实现了与文法中的终结符相关联的解释操作。
3. **非终结符表达式**：`SelectExpression` 类实现了与文法中的非终结符相关联的解释操作。
4. **解析输入表达式**：通过组合终结符表达式和非终结符表达式来解析输入的查询语句。
5. **解释和执行**：解析树的根节点调用解释操作，递归地解释并执行查询语句。

### 不符合要求的解释器模式实现

#### 不符合要求的代码实现

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

struct Table {
    std::vector<std::unordered_map<std::string, std::string>> rows;
};

class Context {
public:
    void addTable(const std::string& name, const Table& table) {
        tables[name] = table;
    }

    const Table& getTable(const std::string& name) const {
        return tables.at(name);
    }

private:
    std::unordered_map<std::string, Table> tables;
};

// 缺乏抽象表达式类
class SQLInterpreter {
public:
    SQLInterpreter(Context& context) : context(context) {}

    std::vector<std::unordered_map<std::string, std::string>> interpret(const std::string& query) {
        // 假设输入格式为: SELECT column FROM table WHERE condition
        std::istringstream ss(query);
        std::string select, column, from, table, where, conditionColumn, conditionValue;
        
        ss >> select >> column >> from >> table >> where >> conditionColumn >> conditionValue;

        const Table& tbl = context.getTable(table);

        std::vector<std::unordered_map<std::string, std::string>> result;
        for (const auto& row : tbl.rows) {
            if (row.at(conditionColumn) == conditionValue) {
                result.push_back({{column, row.at(column)}});
            }
        }
        return result;
    }

private:
    Context& context;
};

// 客户端代码
int main() {
    Context context;
    Table users = {
        { { {"name", "Alice"}, {"age", "30"} }, { {"name", "Bob"}, {"age", "25"} }, { {"name", "Charlie"}, {"age", "35"} } }
    };
    context.addTable("users", users);

    // 解释查询语句: SELECT name FROM users WHERE age = 25
    SQLInterpreter interpreter(context);
    auto result = interpreter.interpret("SELECT name FROM users WHERE age 25");

    for (const auto& row : result) {
        std::cout << "name: " << row.at("name") << std::endl;
    }

    return 0;
}
```

### 不符合要求的说明

1. **没有抽象表达式类**：所有的解释逻辑都在 `SQLInterpreter` 类中，没有定义抽象表达式接口。
2. **没有终结符和非终结符表达式的区分**：终结符和非终结符表达式混在一起，职责不清晰。
3. **缺乏灵活性**：扩展和维护变得更加困难，例如添加新的运算符或查询类型需要修改大量代码。
4. **解析和解释混在一起**：没有单独的解析器类来处理查询语句的解析和解释。

### 总结

通过以上改进的示例，展示了如何通过解释器模式实现一个更自动化和灵活的SQL查询解释和执行系统。符合要求的实现通过定义抽象表达式接口、终结符表达式和非终结符表达式，并通过解析器自动解析输入的SQL查询语句，构建解析树并解释和执行查询，使得客户端代码无需了解查询语句的结构。与不符合要求的实现相比，这种实现更符合解释器模式的设计原则，具有更好的扩展性和灵活性。

# **`额外的正反例2：`**

为了实现一个复杂的 SQL 解释器，我们需要支持更多的命令和更复杂的 SQL 查询处理，包括 INSERT、UPDATE、DELETE、CREATE TABLE 等。以下是一个更复杂的 SQL 解释器实现示例，包括解析和执行这些 SQL 语句。

### 符合要求的实现

#### SQL 解释器的类结构

1. **Expression**：表示 SQL 表达式的基类。
2. **Context**：用于存储和操作数据库的上下文。
3. **SQLCommand**：表示 SQL 命令的基类。
4. **具体命令类**：如 `SelectCommand`、`InsertCommand`、`UpdateCommand`、`DeleteCommand` 等。

#### 代码实现

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <stdexcept>

// 前向声明
class Context;

// 表示 SQL 表达式的基类
class Expression {
public:
    virtual void interpret(Context& context) const = 0;
    virtual ~Expression() = default;
};

// SQL 命令的基类
class SQLCommand : public Expression {
protected:
    std::string tableName;
public:
    SQLCommand(const std::string& tableName) : tableName(tableName) {}
};

// 具体命令类：SELECT
class SelectCommand : public SQLCommand {
    std::vector<std::string> columns;
public:
    SelectCommand(const std::string& tableName, const std::vector<std::string>& columns)
        : SQLCommand(tableName), columns(columns) {}
    void interpret(Context& context) const override;
};

// 具体命令类：INSERT
class InsertCommand : public SQLCommand {
    std::map<std::string, std::string> values;
public:
    InsertCommand(const std::string& tableName, const std::map<std::string, std::string>& values)
        : SQLCommand(tableName), values(values) {}
    void interpret(Context& context) const override;
};

// 具体命令类：UPDATE
class UpdateCommand : public SQLCommand {
    std::map<std::string, std::string> values;
    std::string condition;
public:
    UpdateCommand(const std::string& tableName, const std::map<std::string, std::string>& values, const std::string& condition)
        : SQLCommand(tableName), values(values), condition(condition) {}
    void interpret(Context& context) const override;
};

// 具体命令类：DELETE
class DeleteCommand : public SQLCommand {
    std::string condition;
public:
    DeleteCommand(const std::string& tableName, const std::string& condition)
        : SQLCommand(tableName), condition(condition) {}
    void interpret(Context& context) const override;
};

// 具体命令类：CREATE TABLE
class CreateTableCommand : public SQLCommand {
    std::map<std::string, std::string> columns;
public:
    CreateTableCommand(const std::string& tableName, const std::map<std::string, std::string>& columns)
        : SQLCommand(tableName), columns(columns) {}
    void interpret(Context& context) const override;
};

// 上下文类：用于存储和操作数据库
class Context {
    std::map<std::string, std::vector<std::map<std::string, std::string>>> tables;
public:
    void createTable(const std::string& tableName, const std::map<std::string, std::string>& columns) {
        tables[tableName] = std::vector<std::map<std::string, std::string>>();
        std::cout << "Table " << tableName << " created.\n";
    }

    void insert(const std::string& tableName, const std::map<std::string, std::string>& values) {
        tables[tableName].push_back(values);
        std::cout << "Inserted into " << tableName << ".\n";
    }

    void select(const std::string& tableName, const std::vector<std::string>& columns) {
        auto& rows = tables[tableName];
        for (const auto& row : rows) {
            for (const auto& col : columns) {
                std::cout << col << ": " << row.at(col) << " ";
            }
            std::cout << "\n";
        }
    }

    void update(const std::string& tableName, const std::map<std::string, std::string>& values, const std::string& condition) {
        auto& rows = tables[tableName];
        for (auto& row : rows) {
            // 简单条件解析
            if (row["id"] == condition) {
                for (const auto& val : values) {
                    row[val.first] = val.second;
                }
                std::cout << "Updated " << tableName << ".\n";
            }
        }
    }

    void remove(const std::string& tableName, const std::string& condition) {
        auto& rows = tables[tableName];
        rows.erase(std::remove_if(rows.begin(), rows.end(), [&condition](const std::map<std::string, std::string>& row) {
            return row.at("id") == condition;
        }), rows.end());
        std::cout << "Deleted from " << tableName << ".\n";
    }
};

// 实现具体命令的解释方法
void SelectCommand::interpret(Context& context) const {
    context.select(tableName, columns);
}

void InsertCommand::interpret(Context& context) const {
    context.insert(tableName, values);
}

void UpdateCommand::interpret(Context& context) const {
    context.update(tableName, values, condition);
}

void DeleteCommand::interpret(Context& context) const {
    context.remove(tableName, condition);
}

void CreateTableCommand::interpret(Context& context) const {
    context.createTable(tableName, columns);
}

// 解析和执行 SQL 语句
std::shared_ptr<Expression> parseSQL(const std::string& sql) {
    std::istringstream stream(sql);
    std::string command;
    stream >> command;

    if (command == "CREATE") {
        std::string table, tableName;
        stream >> table >> tableName;
        std::map<std::string, std::string> columns;
        std::string colDef;
        while (stream >> colDef) {
            auto pos = colDef.find(':');
            auto colName = colDef.substr(0, pos);
            auto colType = colDef.substr(pos + 1);
            columns[colName] = colType;
        }
        return std::make_shared<CreateTableCommand>(tableName, columns);
    } else if (command == "INSERT") {
        std::string into, tableName;
        stream >> into >> tableName;
        std::map<std::string, std::string> values;
        std::string colVal;
        while (stream >> colVal) {
            auto pos = colVal.find('=');
            auto colName = colVal.substr(0, pos);
            auto colValue = colVal.substr(pos + 1);
            values[colName] = colValue;
        }
        return std::make_shared<InsertCommand>(tableName, values);
    } else if (command == "SELECT") {
        std::vector<std::string> columns;
        std::string colName;
        while (stream >> colName && colName != "FROM") {
            columns.push_back(colName);
        }
        std::string tableName;
        stream >> tableName;
        return std::make_shared<SelectCommand>(tableName, columns);
    } else if (command == "UPDATE") {
        std::string tableName;
        stream >> tableName;
        std::map<std::string, std::string> values;
        std::string colVal;
        while (stream >> colVal && colVal != "WHERE") {
            auto pos = colVal.find('=');
            auto colName = colVal.substr(0, pos);
            auto colValue = colVal.substr(pos + 1);
            values[colName] = colValue;
        }
        std::string condition;
        stream >> condition;
        return std::make_shared<UpdateCommand>(tableName, values, condition);
    } else if (command == "DELETE") {
        std::string from, tableName;
        stream >> from >> tableName >> from;
        std::string condition;
        stream >> condition;
        return std::make_shared<DeleteCommand>(tableName, condition);
    }

    throw std::runtime_error("Unknown SQL command");
}

int main() {
    Context context;

    std::vector<std::string> commands = {
        "CREATE TABLE users id:int name:string age:int",
        "INSERT INTO users id=1 name=Alice age=30",
        "INSERT INTO users id=2 name=Bob age=25",
        "SELECT id name age FROM users",
        "UPDATE users SET age=26 WHERE id=2",
        "DELETE FROM users WHERE id=1",
        "SELECT id name age FROM users"
    };

    for (const auto& sql : commands) {
        try {
            auto command = parseSQL(sql);
            command->interpret(context);
        } catch (const std::exception& ex) {
            std::cerr << "Exception: " << ex.what() << std::endl;
        }
    }

    return 0;
}
```

### 不符合要求的实现
