### 22、数学表达式（202400611）
>**题目描述**  
- 小明所在的公司请假需要在OA系统上发布申请，整个请求流程包括多个处理者，每个处理者负责处理不同范围的请假天数，如果一个处理者不能处理请求，就会将请求传递给下一个处理者，请你实现责任链模式，可以根据请求天数找到对应的处理者。

- 审批责任链由主管(Supervisor), 经理(Manager)和董事（Director)组成，他们分别能够处理3天、7天和10天的请假天数。如果超过10天，则进行否决。

>**输入描述**  
- 第一行是一个整数N（1 <= N <= 100), 表示请求申请的数量。

- 接下来的N行，每行包括一个请求申请的信息，格式为"姓名 请假天数"

>**输出描述**  
- 对于每个请假请求，输出一行，表示该请求是否被批准。如果被批准/否决，输出被哪一个职级的人批准/否决。

>**输入示例**  
4  
Alice 2  
Bob 5  
Tom 10  
Jerry 12     
  
>**输出示例**  
Alice Approved by Supervisor.  
Bob Approved by Manager.  
Tom Approved by Director.  
Jerry Denied by Director.   


>自己答案（去掉注释）
```C++
#include <iostream>
#include <memory>
#include <stack>
#include <string>
#include <sstream>  // 使用istringstream需要的头文件

using namespace std;

class Expression {
public:
    virtual double interpret() = 0;

    virtual ~Expression() = default;
};

class NumberExpression : public Expression{
private:
    double value;
    
public:
    double interpret() override{
        return value;
    }
    
    NumberExpression(double val) : value(val){}
};

class BinaryExpression : public Expression{
protected:
    shared_ptr<Expression> left;     // shared<Expression> left;  shared_ptr<>名字写错。。
    shared_ptr<Expression> right;    // shared<Expression> right;
    
public:
    // shared<Expression> left
    BinaryExpression(shared_ptr<Expression> left, shared_ptr<Expression> right) : left(left), right(right){}
};  // 忘记了分号！

class AddExpression : public BinaryExpression {
public:
    using BinaryExpression::BinaryExpression;
    
    double interpret() override{
        return left->interpret() + right->interpret();  // return left->interpret + right->interpret;方法名少了括号。。
    }
};

class SubExpression : public BinaryExpression {
public:
    using BinaryExpression::BinaryExpression;
    
    double interpret() override{
        return left->interpret() - right->interpret();
    }
};

class MultExpression : public BinaryExpression {
public:
    using BinaryExpression::BinaryExpression;
    
    double interpret() override{
        return left->interpret() * right->interpret();
    }
};

class DivExpression : public BinaryExpression {
public:
    using BinaryExpression::BinaryExpression;
    
    double interpret() override{
        return left->interpret() / right->interpret();  // 如何避免除以零？
    }
};

class Evalutor{
public:
    stack<shared_ptr<Expression>> exps;
    stack<char> ops;
    shared_ptr<Expression> styx_tree;
    
    string tokenize(string str);
    shared_ptr<Expression> expressDeal(string input);
    
    // Evalutor(const string context){
    //     string dealed = tokenize(context);  // 将输入处理为规范的表达式
    //     istringstream iss(dealed);
    //     styx_tree = expressDeal(iss);
    // }
    Evalutor(){}  // 这里要改？
};

int priority(char op){
    if(op == '+' || op == '-') { return 1; }
    else if(op == '*' || op == '/') { return 2; }
    else{ cout << "Wrong op." << endl; return 0;}
}

string Evalutor::tokenize(string str){
    string result;
    
    for(auto ch : str){
        if(isspace(ch)){ continue; }
        if(isdigit(ch) || ch == '.'){
            result += ch;    // 数字拼凑在一起
        }else{
            // result = result + ' ' + ch + ' ';  // 符号与数字隔开
            result += ' ';   
            result += ch ;
            result += ' ';
        }
    }
    return result;
}

// shared<Expression> Evalutor::expressDeal(istringstream input){
shared_ptr<Expression> Evalutor::expressDeal(string input){
    // string dealed = tokenize(input);  // 将输入处理为规范的表达式
    string dealed; 
    dealed = tokenize(input); 
    istringstream iss(dealed);
    // styx_tree = expressDeal(iss);
    string str;
    
    auto applyOps = [&] (char op) {
        // auto left = exps.top(); exps.pop();
        // auto right = exps.top(); exps.pop();   这里应该先把栈头上的数据给right。。
        auto right = exps.top(); exps.pop();
        auto left = exps.top(); exps.pop();
        
        if(op == '+') { exps.push(make_shared<AddExpression>(left, right)); }
        else if(op == '-') { exps.push(make_shared<SubExpression>(left, right)); }
        else if(op == '*') { exps.push(make_shared<MultExpression>(left, right)); }
        else if(op == '/') { exps.push(make_shared<DivExpression>(left, right)); }
    };  // 这里需要一个分号，lambda表达式算一个语句！！！
    
    while(iss >> str){
        if(isdigit(str[0])){  // if(isdigit[str[0]])方法使用错误，不是方括号，而是圆括号
            exps.push(make_shared<NumberExpression>(stod(str)));  // exps.push(stod(str));  exps存的是数字表达式类，而不是纯粹数值。。
        }else if(str == "("){  // else if(str == '(' string不能和字符char比较。。
            // ops.push(str[0]);  // ops.push(str); ops是字符栈，不能放字符串。。
            ops.push('(');
        }else if(str == ")"){       // 当前的右括号中最多只有一个低阶运算加一个高阶运算（1+2*3）
            while(!ops.empty() && ops.top() != '('){  // 将当前括号运算完. !ops.empty()条件漏了
                applyOps(ops.top());
                ops.pop();            // 将括号中当前的运算符去掉，因为已经运算过了
            }  
            ops.pop();  // 将左括号去掉，当前括号运算完成！
        }else if(str == "+" || str == "-" || str == "*" || str == "/"){
            // if(!ops.empty() && priority(ops.top()) >= priority(str[0])){   // 栈中运算符大于当前读取的运算符，则进行运算
            //     applyOps(ops.top());
            //     ops.pop();
            //     ops.push(str[0]);  // ops.push(str);
            // }
            while(!ops.empty() && priority(ops.top()) >= priority(str[0])){   // 改为了while！！！
                applyOps(ops.top());
                ops.pop();
            }
            ops.push(str[0]);
        }
    }
    while(!ops.empty()){  // 最后应该是无括号情况，且最多只有一个低阶运算加一个高阶运算1+2*3
        applyOps(ops.top());
        ops.pop();
    }
    return exps.top();
}


int main(){
    string input;
    
    Evalutor caculator;
    while(getline(cin, input)){
        shared_ptr<Expression> styx_tree = caculator.expressDeal(input);
        double value = styx_tree->interpret();
        cout << value << endl;
    }
}
```

>自己答案（调试后，通过!!!）
```C++
#include <iostream>
#include <memory>  // #include <memeory>  拼写错误
#include <string>
#include <sstream>

using namespace std;


class AskForLeave {
public:
    string getName(){
        return name;
    }
    
    int getDays(){
        return days;
    }
    
    AskForLeave(string name, int days) : name(name), days(days){}
private:
    string name;
    int days;
};

class Approver {
public:
    void setNextApprover(shared_ptr<Approver> next_approver){
        next = next_approver;
    }
    
    void operation(shared_ptr<AskForLeave> new_request){
        if(canProcess(new_request)){
            process(new_request);
        }else if(next){
            next->operation(new_request);  // next->process(new_request);
        }else{
            cout << "Can't deal with this request." << endl;
        }
    }
    
    void setNext(shared_ptr<Approver> new_next){
        next = new_next;
    }
    
    virtual ~Approver() = default;
    
private:   //  设置成私有的，有什么好处？
    shared_ptr<Approver> next;

protected:  // 设置成保护的，有什么好处？
    // canProcess 和 process 方法只需要在 Approver 类和其派生类中访问，因此将它们设为 protected，可以隐藏实现细节，不对外暴露这些方法，增强类的封装性
    virtual bool canProcess(shared_ptr<AskForLeave> new_request) = 0;
    virtual void process(shared_ptr<AskForLeave> new_request) = 0;
};

class Supervisor : public Approver {
protected:
    bool canProcess(shared_ptr<AskForLeave> new_request) override {
        if(new_request->getDays() <= 3) return true;
        else return false;
    }
    
    void process(shared_ptr<AskForLeave> new_request) override {
        cout << new_request->getName() << " Approved by Supervisor." << endl;
    }
};

class Manager : public Approver {
protected:
    bool canProcess(shared_ptr<AskForLeave> new_request) override {
        if(new_request->getDays() <= 7) return true;
        else return false;
    }
    
    void process(shared_ptr<AskForLeave> new_request) override {
        cout << new_request->getName() << " Approved by Manager." << endl;
    }
};

class Director : public Approver {
protected:
    bool canProcess(shared_ptr<AskForLeave> new_request) override {
        if(new_request->getDays() > 7) return true;  // 注意条件范围if(new_request->getDays() >= 10) return true;
        else return false;
    }
    
    void process(shared_ptr<AskForLeave> new_request) override {
        if(new_request->getDays() <= 10){    
            cout << new_request->getName() << " Approved by Director." << endl;  // 注意题目要求，大于10要Denied，而不是不处理
        }else{
            cout << new_request->getName() << " Denied by Director." << endl;  // 注意题目要求，大于10要Denied，而不是不处理
        }
    }
};

int main(){
    int count;
    cin >> count;
    cin.ignore();
    
    string input;
    
    shared_ptr<Approver> supervisor = make_shared<Supervisor>();
    shared_ptr<Approver> manager = make_shared<Manager>();
    shared_ptr<Approver> director = make_shared<Director>();
    
    // supervisor->next = manager;
    // manager->next = director;
    supervisor->setNext(manager);
    manager->setNext(director);
    
    while(getline(cin, input)){
        string tmp_name;
        int tmp_days;
        
        istringstream oss(input);
        oss >> tmp_name >> tmp_days;
        
        shared_ptr<AskForLeave> cur_request = make_shared<AskForLeave>(tmp_name, tmp_days);
        
        supervisor->operation(cur_request);
    }
    
    return 0;
}
```
![alt text](77860f2d2bce83cdf5822e7d32cefab.png)



> **卡码网答案**
```C++
#include <iostream>
#include <sstream>
 
class LeaveHandler {
public:
    virtual void handleRequest(const std::string& name, int days) = 0;
};
 
class Supervisor : public LeaveHandler {
private:
    static const int MAX_DAYS_SUPERVISOR_CAN_APPROVE = 3;
    LeaveHandler* nextHandler;
 
public:
    Supervisor(LeaveHandler* nextHandler) : nextHandler(nextHandler) {}
 
    void handleRequest(const std::string& name, int days) override {
        if (days <= MAX_DAYS_SUPERVISOR_CAN_APPROVE) {
            std::cout << name << " Approved by Supervisor." << std::endl;
        } else if (nextHandler != nullptr) {
            nextHandler->handleRequest(name, days);
        } else {
            std::cout << name << " Denied by Supervisor." << std::endl;
        }
    }
};
 
class Manager : public LeaveHandler {
private:
    static const int MAX_DAYS_MANAGER_CAN_APPROVE = 7;
    LeaveHandler* nextHandler;
 
public:
    Manager(LeaveHandler* nextHandler) : nextHandler(nextHandler) {}
 
    void handleRequest(const std::string& name, int days) override {
        if (days <= MAX_DAYS_MANAGER_CAN_APPROVE) {
            std::cout << name << " Approved by Manager." << std::endl;
        } else if (nextHandler != nullptr) {
            nextHandler->handleRequest(name, days);
        } else {
            std::cout << name << " Denied by Manager." << std::endl;
        }
    }
};
 
class Director : public LeaveHandler {
private:
    static const int MAX_DAYS_DIRECTOR_CAN_APPROVE = 10;
 
public:
    void handleRequest(const std::string& name, int days) override {
        if (days <= MAX_DAYS_DIRECTOR_CAN_APPROVE) {
            std::cout << name << " Approved by Director." << std::endl;
        } else {
            std::cout << name << " Denied by Director." << std::endl;
        }
    }
};
 
class LeaveRequest {
private:
    std::string name;
    int days;
 
public:
    LeaveRequest(const std::string& name, int days) : name(name), days(days) {}
 
    std::string getName() const {
        return name;
    }
 
    int getDays() const {
        return days;
    }
};
 
int main() {
    int n;
    std::cin >> n;
    std::cin.ignore(); 
 
    LeaveHandler* director = new Director();
    LeaveHandler* manager = new Manager(director);
    LeaveHandler* supervisor = new Supervisor(manager);
 
    for (int i = 0; i < n; i++) {
        std::string input;
        std::getline(std::cin, input);
        std::istringstream iss(input);
         
        std::string name;
        int days;
         
        if (iss >> name >> days) {
            LeaveRequest request(name, days);
            supervisor->handleRequest(name, days);
        } else {
            std::cout << "Invalid input" << std::endl;
            return 1;
        }
    }
 
    delete supervisor;
    delete manager;
    delete director;
 
    return 0;
}
```