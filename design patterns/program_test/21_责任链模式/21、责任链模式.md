### 20、开关台灯（202400605）
>**题目描述**  
- 小明家有一个灯泡，刚开始为关闭状态（OffState）。台灯可以接收一系列的指令，包括打开（"ON"）、关闭（"OFF"）和闪烁（"blink"）。每次接收到一个指令后，台灯会执行相应的操作，并输出当前灯泡的状态。请设计一个程序模拟这个灯泡系统。

>**输入描述**  
- 第一行是一个整数 n（1 <= n <= 1000），表示接收的命令数量。 

- 接下来的 n 行，每行包含一个字符串 s，表示一个命令（"ON"、"OFF"或"blink"）

>**输出描述**  
- 对于每个命令，输出一行，表示执行该命令后灯泡的状态.

>**输入示例**  
5  
ON  
OFF  
BLINK  
OFF  
ON     
  
>**输出示例**  
Light is ON  
Light is OFF  
Light is Blinking  
Light is OFF  
Light is ON   


>自己答案（去掉注释）
```C++


```
![alt text](image.png)


>自己答案（调试后，通过!!!）
```C++
#include <iostream>
#include <memory>  // #include <memeory>  拼写错误
#include <string>
#include <sstream>

using namespace std;


class AskForLeave {
public:
    string getName(){
        return name;
    }
    
    int getDays(){
        return days;
    }
    
    AskForLeave(string name, int days) : name(name), days(days){}
private:
    string name;
    int days;
};

class Approver {
public:
    void setNextApprover(shared_ptr<Approver> next_approver){
        next = next_approver;
    }
    
    void operation(shared_ptr<AskForLeave> new_request){
        if(canProcess(new_request)){
            process(new_request);
        }else if(next){
            next->operation(new_request);  // next->process(new_request);
        }else{
            cout << "Can't deal with this request." << endl;
        }
    }
    
    void setNext(shared_ptr<Approver> new_next){
        next = new_next;
    }
    
    virtual ~Approver() = default;
    
private:   //  设置成私有的，有什么好处？
    shared_ptr<Approver> next;

protected:  // 设置成保护的，有什么好处？
    // canProcess 和 process 方法只需要在 Approver 类和其派生类中访问，因此将它们设为 protected，可以隐藏实现细节，不对外暴露这些方法，增强类的封装性
    virtual bool canProcess(shared_ptr<AskForLeave> new_request) = 0;
    virtual void process(shared_ptr<AskForLeave> new_request) = 0;
};

class Supervisor : public Approver {
protected:
    bool canProcess(shared_ptr<AskForLeave> new_request) override {
        if(new_request->getDays() <= 3) return true;
        else return false;
    }
    
    void process(shared_ptr<AskForLeave> new_request) override {
        cout << new_request->getName() << " Approved by Supervisor." << endl;
    }
};

class Manager : public Approver {
protected:
    bool canProcess(shared_ptr<AskForLeave> new_request) override {
        if(new_request->getDays() <= 7) return true;
        else return false;
    }
    
    void process(shared_ptr<AskForLeave> new_request) override {
        cout << new_request->getName() << " Approved by Manager." << endl;
    }
};

class Director : public Approver {
protected:
    bool canProcess(shared_ptr<AskForLeave> new_request) override {
        if(new_request->getDays() > 7) return true;  // 注意条件范围if(new_request->getDays() >= 10) return true;
        else return false;
    }
    
    void process(shared_ptr<AskForLeave> new_request) override {
        if(new_request->getDays() <= 10){    
            cout << new_request->getName() << " Approved by Director." << endl;  // 注意题目要求，大于10要Denied，而不是不处理
        }else{
            cout << new_request->getName() << " Denied by Director." << endl;  // 注意题目要求，大于10要Denied，而不是不处理
        }
        
    }
};

int main(){
    int count;
    cin >> count;
    cin.ignore();
    
    string input;
    
    shared_ptr<Approver> supervisor = make_shared<Supervisor>();
    shared_ptr<Approver> manager = make_shared<Manager>();
    shared_ptr<Approver> director = make_shared<Director>();
    
    // supervisor->next = manager;
    // manager->next = director;
    supervisor->setNext(manager);
    manager->setNext(director);
    
    while(getline(cin, input)){
        string tmp_name;
        int tmp_days;
        
        istringstream oss(input);
        oss >> tmp_name >> tmp_days;
        
        shared_ptr<AskForLeave> cur_request = make_shared<AskForLeave>(tmp_name, tmp_days);
        
        supervisor->operation(cur_request);
    }
    
    return 0;
}
```
![alt text](77860f2d2bce83cdf5822e7d32cefab.png)



> **卡码网答案**
```C++

```