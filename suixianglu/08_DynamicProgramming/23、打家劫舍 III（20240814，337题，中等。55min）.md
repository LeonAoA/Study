### 23、打家劫舍 III（20240814，337题，中等。55min）
<div style="border: 1px solid black; padding: 10px; background-color: SteelBlue;">



  </p>
</div>

<hr style="border-top: 5px solid #DC143C;">
<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己答案（55min，通过！）
      </span>
    </td>
  </tr>
</table>
<div style="padding: 0px; border: 1.5px solid LightSalmon; margin-bottom: 10px;">

```C++
/*
55min
思路：
每个节点能提供的价值可以考虑左右子树的返回值A1、A2和本身的价值A（不对，结合后面思路要）
    三者谁大返回谁
    返回A1,说明取的左子树；返回A2，取的右子树
    返回自身A，说明取的自身
另外需要考虑
    若取子树返回，则父节点可以采用自身
    若取自身返回，则父节点不能累加自身值

采用左右中，后序遍历
    递归函数应该返回一个元组，即使用自身的最大值和不使用自身的最大值，pair<int, int> choise
    使用自身，则加上左右子树返回来的不使用自身的second；
    不使用自身，左右子树挑选first和second中最大的，并相加！！

pair<int, int> choise
    first参数是使用自身
    second不使用自身
*/
class Solution {
public:
    pair<int, int> travelTree(TreeNode* cur_node){
        if(cur_node->left == nullptr && cur_node->right == nullptr){
            return make_pair(cur_node->val, 0);
        }

        // int left = 0;
        // int right = 0;
        pair<int, int> left = {0, 0};
        pair<int, int> right = {0, 0};

        if(cur_node->left){
            pair<int, int> tmp_left = travelTree(cur_node->left);
            left.first = tmp_left.first;
            left.second = tmp_left.second;
        }
        if(cur_node->right){
            pair<int, int> tmp_right = travelTree(cur_node->right);
            right.first = tmp_right.first;
            right.second = tmp_right.second;
        }
        
        // 使用自身，则加上左右子树返回来的不使用自身的second
        int use_self = cur_node->val + left.second + right.second;
        // 不使用自身，左右子树挑选first和second中最大的，并相加
        int without_self = max(left.first, left.second) + max(right.first, right.second);

        return make_pair(use_self, without_self);
    }

    int rob(TreeNode* root) {

        pair<int, int> ret = travelTree(root);

        return max(ret.first, ret.second);
    }
};
```

</div>

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己答案（通过！）
      </span>
    </td>
  </tr>
</table>

<div style="padding: 0px; border: 1.5px solid LightSalmon; margin-bottom: 10px">

```C++


```
</div>

<hr style="border-top: 5px solid #DC143C;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己调试版本（通过！！！）
      </span>
    </td>
  </tr>
</table>

<div style="padding: 0px; border: 1.5px solid LightSalmon; margin-bottom: 10px">

```C++


```
</div>

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      仿照答案版本v2（去注释）
      </span>
    </td>
  </tr>
</table>

<div style="padding: 0px; border: 1.5px solid LightSalmon; margin-bottom: 10px">

```C++


```
</div>

<hr style="border-top: 5px solid #DC143C;">


<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      随想录答案
      </span>
    </td>
  </tr>
</table>

<div style="padding: 0px; border: 1.5px solid LightSalmon; margin-bottom: 10px">

```C++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```
</div>

时间复杂度：O(n)，每个节点只遍历了一次  
空间复杂度：O(log n)，算上递推系统栈的空间

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      随想录答案
      </span>
    </td>
  </tr>
</table>

<div style="padding: 0px; border: 1.5px solid LightSalmon; margin-bottom: 10px">

```C++
// 暴力递归
class Solution {
public:
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        // 偷父节点
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); // 跳过root->left，相当于不考虑左孩子了
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); // 跳过root->right，相当于不考虑右孩子了
        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
        return max(val1, val2);
    }
};

// 记忆化递推
class Solution {
public:
    unordered_map<TreeNode* , int> umap; // 记录计算过的结果
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        if (umap[root]) return umap[root]; // 如果umap里已经有记录则直接返回
        // 偷父节点
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); // 跳过root->left
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); // 跳过root->right
        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
        umap[root] = max(val1, val2); // umap记录一下结果
        return max(val1, val2);
    }
};
```
</div>