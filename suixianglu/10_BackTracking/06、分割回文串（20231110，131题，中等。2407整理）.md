### 06、分割回文串（20231110，131题，中等。2407整理）
<div style="border: 1px solid black; padding: 10px; background-color: #00BFFF;">

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回 s 所有可能的分割方案。

示例: 
- 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ]

  </p>
</div>

<hr style="border-top: 5px solid #DC143C;">
<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己答案（去注释，通过！）
      </span>
    </td>
  </tr>
</table>

```C++


```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己答案（通过！）
      </span>
    </td>
  </tr>
</table>

```C++


```

<hr style="border-top: 5px solid #DC143C;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己的答案，ChatGPT修改，通过。
      </span>
    </td>
  </tr>
</table>

```C++
/*
思路：
字符串的切合可以类比数字的组合，在每个字符后面的缝隙切一刀，就是对字符的重新组合
"aab"在“b”前面切一刀，就是分成了“aa”和“b”的组合。
切完一刀后，需要判断左边部分是否为回文，不是则不用继续切割，因为当前这个已经不是回文；
然后继续递归切割，一直切刀字符串最后位置停止；
若此时最后切割出的字符串也满足回文要求，则将当前结果存入ret中。

backtracking（string s，int pre_index）
将原字符串传递进入，之前切的位置传入；函数中再遍历，决定当前回溯层级的切割位置，下次回溯将次位置作为索引传入。
*/

class Solution {
public:
    vector<vector<string>> ret;  //存储找到的结果
    vector<string> tmp;  //存储回溯中的字符串

    bool isPalindrome(string s)  //判断字符串是否为回文
    {
        string  reve_str = s;
        reverse(reve_str.begin(), reve_str.end());
        return (reve_str == s);
    }

    void backtracking(string s, int pre_index)  //递归遍历字符串，即切割过程
    {
        if(pre_index == s.size())
        {
            ret.push_back(tmp);  //找到了回文字符串
            return;
        }
        for(int i = pre_index + 1; i <= s.size(); i++)  //层级遍历
        {
            string str_cur = s.substr(pre_index, i - pre_index);  /*不是s.substr(pre_index, i)。从pre_index处开始，取(i - pre_index)个字符*/
            if(!isPalindrome(str_cur))  //当前切割的不是回文字符串
            {
                continue;   /*不能return！！！“bcbc”，切刀“bc”，可以让他继续切到“bcbc”最后，也是回文！*/
            }
            tmp.push_back(str_cur);
            backtracking(s, i);
            tmp.pop_back();    /*tmp.pop_back(str_cur);*/
        }
    }

    vector<vector<string>> partition(string s) {

        backtracking(s, 0);
        return ret;
    }
};
```
![Alt text](image/image-53.png)


<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      仿照答案版本v2（去注释）
      </span>
    </td>
  </tr>
</table>

```C++


```

<hr style="border-top: 5px solid #DC143C;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      仿照答案版本v2
      </span>
    </td>
  </tr>
</table>

```C++


```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      随想录答案
      </span>
    </td>
  </tr>
</table>

```C++


```
