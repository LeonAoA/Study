### 04、组合总和（20231024，39题，中等。2407整理）
<div style="border: 1px solid black; padding: 10px; background-color: #00BFFF;">

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。

示例 1：

- 输入：candidates = [2,3,6,7], target = 7,
- 所求解集为： [ [7], [2,2,3] ]

示例 2：

- 输入：candidates = [2,3,5], target = 8,
- 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ]

  </p>
</div>

<hr style="border-top: 5px solid #DC143C;">
<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己答案（去注释，通过！）
      </span>
    </td>
  </tr>
</table>

```C++


```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己答案（通过！）
      </span>
    </td>
  </tr>
</table>

```C++


```

<hr style="border-top: 5px solid #DC143C;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己调试答案，通过！
      </span>
    </td>
  </tr>
</table>

```C++
/*
每次递归可选的集合都为candidates，每次选取一个数字，并存入path中；
递归次数不确定，限定条件为和sum等于target时，返回ret;
每次递归不需要将当前遍历哪个数告诉下一次递归，因为下一次可以选这个数字？应该是要只选大于等于当前索引的数字
*/

class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;
    int sum = 0;

    void backtracking(vector<int>& candidates, int target, int index)
    {
        if(sum == target)
        {
            ret.push_back(path);
            return;
        }
        if(sum > target)
        {
            return;
        }
        for(int j = index; j < candidates.size(); j++)
        {
            path.push_back(candidates[j]);
            sum += candidates[j];
            backtracking(candidates, target, j);
            sum -= candidates[j];    //不是sum += candidates[j];
            path.pop_back();  //别忘了加这句！！！
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        if(candidates.size() == 0)
        {
            return ret;
        }
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0);
        return ret;
    }
};
```
![Alt text](image/image-33.png)

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己的答案，未通过。
      </span>
    </td>
  </tr>
</table>

```C++
/*
每次递归可选的集合都为candidates，每次选取一个数字，并存入path中；
递归次数不确定，限定条件为和sum等于target时，返回ret;
每次递归不需要将当前遍历哪个数告诉下一次递归，因为下一次可以选这个数字？应该是要只选大于等于当前索引的数字
*/

class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;
    int sum = 0;

    void backtracking(vector<int>& candidates, int target)
    {
        if(sum == target)
        {
            ret.push_back(path);
            return;
        }
        if(sum > target)
        {
            return;
        }
        for(int j = 0; j < candidates.size(); j++)
        {
            path.push_back(candidates[j]);
            sum += candidates[j];
            backtracking(candidates, target);
            sum -= candidates[j];    //不是sum += candidates[j];
            path.pop_back();  //别忘了加这句！！！
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        if(candidates.size() == 0)
        {
            return ret;
        }
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target);
        return ret;
    }
};
```

<hr style="border-top: 5px solid #DC143C;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      仿照答案版本v2
      </span>
    </td>
  </tr>
</table>

```C++


```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      随想录答案
      </span>
    </td>
  </tr>
</table>

```C++


```
