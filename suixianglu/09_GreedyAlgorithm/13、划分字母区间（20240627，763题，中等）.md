### 13、划分字母区间（20240627，763题，中等）
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

示例：

- 输入：S = "ababcbacadefegdehijhklij"
- 输出：[9,7,8] 解释： 划分结果为 "ababcbaca", "defegde", "hijhklij"。 每个字母最多出现在一个片段中。 像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。

提示：

- S的长度在[1, 500]之间。
- S只包含小写字母 'a' 到 'z' 。

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;">自己答案（去注释，通过！）</span>
    </td>
  </tr>
</table>

```C++
/*
思路：
从第一个字母开始，搜索到后续的最后一个相同字母的同时，记录中间遇到了哪些字母，
并且后续也不能有这些字母。这些字符构成了一个所需片段。

先遍历所有的字符，并记录每种字符的个数（？）和最大索引，
    遍历时，第一个字符为a的话，直到a最后的位置i，随时更新遍历的最大索引index，
    遍历到最大索引后，即为一个小片段；
    后续重复步骤即可
*/

class Solution {
public:
    vector<int> partitionLabels(string s) {
        unordered_map<char, int> map;
        for(int i = 0; i < s.size(); i++){
            char ch = s[i];
            if(map.find(ch) == map.end() || map[ch] < i){
                map[ch] = i;
            }
        }
        
        int max_index = map[s[0]];
        vector<int> result;
        // result.push_back(0);
        int pre_index = 0;
        for(int i = 0; i < s.size(); i++){
            char ch = s[i];
            int cur_index = map[ch];

            if(cur_index == s.size()-1){
                result.push_back(i-pre_index+1);
                return result;
            }
            // if(cur_index == max_index)
            if(i == max_index){  // 所搜到了这一片段最后索引
                result.push_back(i-pre_index+1);
                pre_index = i+1;
            }
            if(cur_index > max_index){  // 中间有字符出现在两个a之间，并且出现在第二个a之后。或者找到第一片段，到第二片段第一个点的时候
                max_index = cur_index;
            }
        }
        // for(int i = 0; i < s.size(); i++){
        //     char ch = s[i];
        //     int cur_index = map[ch];

        //     if(cur_index == s.size()-1){
        //         result.push_back(i);
        //         return result;
        //     }
        //     // if(cur_index == max_index)
        //     if(i == max_index){  // 所搜到了这一片段最后索引
        //         result.push_back(i);
        //     }
        //     if(cur_index > max_index){  // 中间有字符出现在两个a之间，并且出现在第二个a之后。或者找到第一片段，到第二片段第一个点的时候
        //         max_index = cur_index;
        //     }
        // }
        return result;
    }
};

```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;">自己答案（通过！）</span>
    </td>
  </tr>
</table>

```C++


```

<hr style="border-top: 5px solid #333;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;">自己调试版本（通过！！！）</span>
    </td>
  </tr>
</table>

```C++


```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;">仿照答案版本v2（去注释）</span>
    </td>
  </tr>
</table>

```C++


```

<hr style="border-top: 5px solid #333;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;">仿照答案版本v2</span>
    </td>
  </tr>
</table>

```C++


```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;">随想录答案</span>
    </td>
  </tr>
</table>

```C++


```
