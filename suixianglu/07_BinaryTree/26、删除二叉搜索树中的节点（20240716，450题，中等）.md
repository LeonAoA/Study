### 26、删除二叉搜索树中的节点（20240716，450题，中等）
<div style="border: 1px solid black; padding: 10px; background-color: #00BFFF;">

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

- 首先找到需要删除的节点；  
- 如果找到了，删除它。
 

示例 1:

![alt text](image/2fe2c40f9f0ea6321efc0214788e1a2.png)

- 输入：root = [5,3,6,2,4,null,7], key = 3
- 输出：[5,4,6,2,null,null,7]
- 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。  
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。  
另一个正确答案是 [5,2,6,null,4,null,7]。 

![alt text](image/0a0d3239d90eaa6ad650aa6d1e7ec23.png)

示例 2:

- 输入: root = [5,3,6,2,4,null,7], key = 0
- 输出: [5,3,6,2,4,null,7]
- 解释: 二叉树不包含值为 0 的节点

示例 3:

- 输入: root = [], key = 0
- 输出: []
 

提示:

- 节点数的范围 [0, 104].
- -105 <= Node.val <= 105
- 节点值唯一
- root 是合法的二叉搜索树
- -105 <= key <= 105
 

进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。

  </p>
</div>

<hr style="border-top: 5px solid #DC143C;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己答案（小优化）
      </span>
    </td>
  </tr>
</table>

```C++
 /*
 思路：
找到需要删除的节点B，
    若B存在右子节点B2，则找到B2的最左节点B2n，将B的左子节点B1作为B2n的左子节点！
        （与此类似的是B存在左子结点B1，可以找到B1的最右节点B1n，将B2作为其右子节点插入）
    若B不存在右子节点B2，则直接考虑下一步
接着看B的父节点A情况：
    若A是根节点，有B2，则返回B2；
    若A是不是根节点
        若B是A的左子节点，
            B存在B2，则A的左子节点改为B2；
            B不存在B2,则A的左子节点改为B1；
        若B是A的右子节点，
            B存在B2，则A的右子节点改为B2；
            B不存在B2,则A的右子节点改为B1；
 */

// 删除根节点也统一处理
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {

        TreeNode* parent = root;
        TreeNode* cur_node = root;
        while(cur_node != nullptr){  // 找需要改的节点
            if(cur_node->val > key){
                parent = cur_node;
                cur_node = cur_node->left;
            }else if(cur_node->val < key){
                parent = cur_node;
                cur_node = cur_node->right;
            }else{
                break;
            }
        }
        if(cur_node != nullptr){  // 存在需要改的节点 
            if(cur_node->right != nullptr){  // 待删除节点存在右节点情况
                TreeNode* cur1 = cur_node->right;
                TreeNode* pre1 = cur1;
                while(cur1 != nullptr){
                    pre1 = cur1;
                    cur1 = cur1->left;
                }
                pre1->left = cur_node->left;
                if(cur_node == root){  // 删除的是根节点
                    TreeNode* ret = cur_node->right;
                    delete root;
                    return ret;
                }else if(parent->left == cur_node){
                    parent->left = cur_node->right;
                }else if(parent->right == cur_node){
                    parent->right = cur_node->right;
                }else{
                    return nullptr;  // 不可能走到这
                }
                delete cur_node;
            }else{  // 待删除节点不存在右节点情况
                if(cur_node == root){  // 删除的是根节点
                    TreeNode* ret = cur_node->left;
                    delete root;
                    return ret;
                }
                else if(parent->left == cur_node){
                    parent->left = cur_node->left;
                }else if(parent->right == cur_node){
                    parent->right = cur_node->left;
                }else{
                    return nullptr;  // 不可能走到这
                }
                delete cur_node;
            }
        }
        return root;
    }
};
```
![alt text](image/4986793fac808d83953ed540fc865c7.png)
<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己答案（通过！）
      </span>
    </td>
  </tr>
</table>

```C++
 /*
 思路：
找到需要删除的节点，看其为父节点的左还是右子节点
    待删除的节点B是父节点A的左子节点：
        B有左子节点则，A左子节点改为B左，B的右子节点接到左子节点右边
        B无左子节点则，A左子节点改为B右，
    待删除的节点B是父节点A的右子节点：
        B有左子节点则，A右子节点改为B左，B的右子节点接到左子节点右边
        B无左子节点则，A右子节点改为B右，
 */

class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode* pre = nullptr;
        TreeNode* cur = root;
        if(root != nullptr && root->val == key){  // 删除根节点情况
            if(root->right != nullptr){
                TreeNode* cur = root->right;
                while(cur != nullptr){
                    pre = cur;
                    cur = cur->left;
                }
                TreeNode* right = root->right;
                pre->left = root->left;
                delete root;
                return right;
            }else{
                TreeNode* left = root->left;
                delete root;
                return left;
            }
        }

        TreeNode* parent = nullptr;
        TreeNode* cur_node = root;
        while(cur_node != nullptr){  // 找需要改的节点
            if(cur_node->val > key){
                parent = cur_node;
                cur_node = cur_node->left;
            }else if(cur_node->val < key){
                parent = cur_node;
                cur_node = cur_node->right;
            }else{
                break;
            }
        }
        if(parent != nullptr && cur_node != nullptr){  // 找到需要改的节点 
            if(cur_node->right != nullptr){  // 待删除节点存在右节点情况
                // TreeNode* pre1 = nullptr;
                TreeNode* cur1 = cur_node->right;
                TreeNode* pre1 = cur1;
                while(cur1 != nullptr){
                    pre1 = cur1;
                    cur1 = cur1->left;
                }
                pre1->left = cur_node->left;
                if(parent->left == cur_node){
                    parent->left = cur_node->right;
                }else if(parent->right == cur_node){
                    parent->right = cur_node->right;
                }else{
                    return nullptr;  // 不可能走到这
                }
                delete cur_node;
            }else{  // 待删除节点不存在右节点情况
                if(parent->left == cur_node){
                    parent->left = cur_node->left;
                }else if(parent->right == cur_node){
                    parent->right = cur_node->left;
                }else{
                    return nullptr;  // 不可能走到这
                }
                delete cur_node;
            }
        }
        return root;
    }
};
```
![alt text](image/202d1d80ca75435079f8bc23bb57019.png)



<hr style="border-top: 5px solid #DC143C;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      自己调试版本（通过！！！）
      </span>
    </td>
  </tr>
</table>

```C++


```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      仿照答案版本v2（去注释）
      </span>
    </td>
  </tr>
</table>

```C++


```

<hr style="border-top: 5px solid #DC143C;">

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      仿照答案版本v2
      </span>
    </td>
  </tr>
</table>

```C++


```

<table>
  <tr>
    <td bgcolor="Yellow" style="padding: 5px; border: 0px solid black;">
      <span style="font-weight: bold; font-size: 20px;color: black;">
      随想录答案
      </span>
    </td>
  </tr>
</table>

```C++


```
