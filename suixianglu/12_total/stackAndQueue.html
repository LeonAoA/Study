<!DOCTYPE html>
<html>
<head>
<title>stackAndQueue.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<ul>
<li><a href="#%E4%B8%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97">三、栈与队列</a>
<ul>
<li><a href="#1%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%9720230719232%E9%A2%98%E7%AE%80%E5%8D%95">1、用栈实现队列（20230719，232题，简单）</a></li>
<li><a href="#2%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%8820230720225%E9%A2%98%E7%AE%80%E5%8D%95">2、用队列实现栈（20230720，225题，简单）</a></li>
</ul>
</li>
<li><a href="#"></a>
<ul>
<li><a href="#3%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B72023072420%E9%A2%98%E7%AE%80%E5%8D%95">3、有效的括号（20230724，20题，简单）</a></li>
</ul>
</li>
<li><a href="#-1"></a>
<ul>
<li><a href="#4%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9202307251047%E9%A2%98%E7%AE%80%E5%8D%95">4、删除字符串中的所有相邻重复项（20230725，1047题，简单）</a></li>
</ul>
</li>
<li><a href="#-2"></a>
<ul>
<li><a href="#5%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC20230726150%E9%A2%98%E4%B8%AD%E7%AD%89">5、逆波兰表达式求值（20230726，150题，中等）</a></li>
</ul>
</li>
</ul>
<h2 id="%E4%B8%89%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97">三、栈与队列</h2>
<h3 id="1%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%9720230719232%E9%A2%98%E7%AE%80%E5%8D%95">1、用栈实现队列（20230719，232题，简单）</h3>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<ul>
<li>void push(int x) 将元素 x 推到队列的末尾</li>
<li>int pop() 从队列的开头移除并返回元素</li>
<li>int peek() 返回队列开头的元素</li>
<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>
</ul>
<p>说明：</p>
<ul>
<li>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p>进阶：</p>
<ul>
<li>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</li>
</ul>
<blockquote>
<p>自己看答案版本，对C++栈声明和函数不熟悉</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> {</span>  
<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; stackIn,stackOut;  <span class="hljs-comment">//用两个栈实现，两个栈同等地位</span>

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Use2Tmp</span><span class="hljs-params">()</span>   <span class="hljs-comment">//不用参数，类中的函数可以调用成员变量</span>
    </span>{
        <span class="hljs-keyword">while</span>(!stackIn.empty())
        {
            stackOut.push(stackIn.top());
            stackIn.pop();
        }
    }

    MyQueue() {

    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{       <span class="hljs-comment">/*正常入栈*/</span>
        stackIn.push(x);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{       <span class="hljs-comment">/*使用两个栈A/B，A出现放入B，则B的栈顶即为队列头元素。B出栈，再入栈A*/</span>
        <span class="hljs-keyword">if</span>(stackOut.empty())
        {
            Use2Tmp();
        }
        <span class="hljs-keyword">int</span> val = stackOut.top();
        stackOut.pop();         <span class="hljs-comment">//栈pop返回的是什么，有返回值？</span>
       <span class="hljs-keyword">return</span> val;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/*使用两个栈A/B，A出现放入B，则B的栈顶即为队列头元素*/</span>
        <span class="hljs-keyword">if</span>(stackOut.empty())
        {
            Use2Tmp();
        }
        <span class="hljs-keyword">return</span> stackOut.top();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> (stackIn.empty() &amp;&amp; stackOut.empty());
    }
};

<span class="hljs-comment">/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj-&gt;push(x);
 * int param_2 = obj-&gt;pop();
 * int param_3 = obj-&gt;peek();
 * bool param_4 = obj-&gt;empty();
 */</span>
</div></code></pre>
<p><img src="image.png" alt="Alt text">
<img src="image-1.png" alt="Alt text"></p>
<hr>
<h3 id="2%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%8820230720225%E9%A2%98%E7%AE%80%E5%8D%95">2、用队列实现栈（20230720，225题，简单）</h3>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<ul>
<li>void push(int x) 将元素 x 压入栈顶。</li>
<li>int pop() 移除并返回栈顶元素。</li>
<li>int top() 返回栈顶元素。</li>
<li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</li>
</ul>
<p>注意：</p>
<ul>
<li>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
</ul>
<p><strong>进阶</strong>：你能否仅用一个队列来实现栈。</p>
<blockquote>
<p>自己看答案版本，对C++队列声明和函数不熟悉</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">/*思路，双队列方法：
队列1为主队列，用于实现各种入栈出栈操作，队列2辅助队列。
每次入队，从队列2入，队列1依次出队列进入队列2。入队完成后，队列2即满足越靠前的是越后面进来的。
最后将队列1和2互换名字，等待相应的操作指令。
*/</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que1;
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; que2;

    MyStack() {

    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{       <span class="hljs-comment">//从队列2入队列，然后将队列1依次入队列2</span>
        que2.push(x);         <span class="hljs-comment">/*que2.push() push函数需要入参*/</span>
        <span class="hljs-keyword">while</span>(!que1.empty())  <span class="hljs-comment">/*que1.empty  empty是函数，别忘记加括号*/</span>
        {
            que2.push(que1.front());   <span class="hljs-comment">/*que1.top()  队列不是top，是front函数*/</span>
            que1.pop();
        }
        swap(que1,que2);    <span class="hljs-comment">/*swap()直接互换队列*/</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{        
        <span class="hljs-keyword">int</span> tmpfront = que1.front();
        que1.pop();
        <span class="hljs-keyword">return</span> tmpfront;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> que1.front();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> que1.empty();
    }
};

<span class="hljs-comment">/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj-&gt;push(x);
 * int param_2 = obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * bool param_4 = obj-&gt;empty();
 */</span>
</div></code></pre>
<h2 id="alt-textalt-text"><img src="image-2.png" alt="Alt text">
<img src="image-3.png" alt="Alt text"></h2>
<h3 id="3%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B72023072420%E9%A2%98%E7%AE%80%E5%8D%95">3、有效的括号（20230724，20题，简单）</h3>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ul>
<blockquote>
<p>自己写版本</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">/*思路：
1、使用栈来做，按顺序入栈，以各类左括号为基准，每次入栈，若是左括号，计数countA，countB,countC，右边括号（思路不行）
2、遇到有括号，必须和上一个入栈的括号是匹配的，并且一起出栈，否则报错。
*/</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; stk;
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">if</span>(s.empty())
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
        {
            stk.push(s[i]);
            <span class="hljs-keyword">switch</span>(s[i])      <span class="hljs-comment">//Switch-case语句格式，Switch用花括号括起来{case 'A':  执行语句； break；}</span>
            {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:
                <span class="hljs-keyword">case</span> <span class="hljs-string">'['</span>:
                <span class="hljs-keyword">case</span> <span class="hljs-string">'{'</span>:
                    <span class="hljs-keyword">continue</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:        <span class="hljs-comment">//出栈，并判断下一个字符是否匹配此括号，匹配也出栈，否则false</span>
                    stk.pop();
                    <span class="hljs-keyword">if</span>(stk.empty())   <span class="hljs-comment">//为什么一定要加这一句？下面的if判断不是已经保证top不为空了吗？？？</span>
                    {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">if</span>(stk.top() != <span class="hljs-string">'('</span>)  <span class="hljs-comment">//包含了第一个字符就是右括号的情况</span>
                    {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">else</span>
                    {
                        stk.pop();
                    }
                    <span class="hljs-keyword">break</span>;             <span class="hljs-comment">//每个case代码块最后要有break语句！！！</span>
                <span class="hljs-keyword">case</span> <span class="hljs-string">']'</span>:        
                    stk.pop();
                    <span class="hljs-keyword">if</span>(stk.empty())
                    {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">if</span>(stk.top() != <span class="hljs-string">'['</span>)   
                    {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">else</span>
                    {
                        stk.pop();
                    }
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'}'</span>:         
                    stk.pop();
                    <span class="hljs-keyword">if</span>(stk.empty())
                    {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">if</span>(stk.top() != <span class="hljs-string">'{'</span>)   
                    {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">else</span>
                    {
                        stk.pop();
                    }
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
        <span class="hljs-keyword">if</span>(stk.empty())
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    }
};
</div></code></pre>
<h2 id="alt-textalt-text"><img src="image-4.png" alt="Alt text">
<img src="image-5.png" alt="Alt text"></h2>
<h3 id="4%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9202307251047%E9%A2%98%E7%AE%80%E5%8D%95">4、删除字符串中的所有相邻重复项（20230725，1047题，简单）</h3>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
在 S 上反复执行重复项删除操作，直到无法继续删除。
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<ul>
<li>输入：&quot;abbaca&quot;<br>
输出：&quot;ca&quot;<br>
解释：
例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</li>
</ul>
<blockquote>
<p>自己版本，没通过！！！</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">/*
思路：
入栈依次删除
一直重复，直到一次遍历中没有删除操作，用计数器标记。
先写一个处理一次遍历的函数，再多次调用。
入栈后判断相同，两个出栈；tmp字符重复赋值栈顶，再入栈并判断。
*/</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; stk;
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">string</span> tmpStr = s;
        <span class="hljs-keyword">char</span> chPre = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">char</span> chCur = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)   <span class="hljs-comment">//不能while(!s.empty())</span>
        {
            chPre = stk.top();
            stk.push(tmpStr[i]);
            i++;
            chCur = stk.top();
            
            <span class="hljs-keyword">if</span>(chCur == chPre &amp;&amp; (stk.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>))
            {
                stk.pop();
                stk.pop();
            }
        }
        <span class="hljs-built_in">string</span> ret;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(!stk.empty())
        {
            ret[j] = stk.top();
            j++;                <span class="hljs-comment">//别忘了累加j</span>
            stk.pop();
        }
        reverse(ret.<span class="hljs-built_in">begin</span>(),ret.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">return</span> ret;
    }
};
</div></code></pre>
<blockquote>
<p>根据答案修改后的自己版本</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; stk;
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">string</span> tmpStr = s;
        <span class="hljs-keyword">char</span> chPre = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">char</span> chCur = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;

        len = tmpStr.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">/*len开始忘记了赋值*/</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)   <span class="hljs-comment">//不能while(!s.empty())</span>
        {
            <span class="hljs-keyword">if</span>(!stk.empty())
            {
                chPre = stk.top();    <span class="hljs-comment">//必须先判空，不然可能top是空的</span>
            }
            <span class="hljs-keyword">if</span>((tmpStr[i] == chPre) &amp;&amp; (stk.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>))
            {
                stk.pop();
            }
            <span class="hljs-keyword">else</span>
            {
                stk.push(tmpStr[i]);
            }            
        }
        <span class="hljs-built_in">string</span> ret;
        <span class="hljs-keyword">while</span>(!stk.empty())
        {
            ret += stk.top(); <span class="hljs-comment">/*string初始化后只能通过拼接来改变字符串*/</span>
            stk.pop();
        }
        reverse(ret.<span class="hljs-built_in">begin</span>(),ret.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">/*熟悉string类的接口*/</span>
        <span class="hljs-keyword">return</span> ret;
    }
};
</div></code></pre>
<p><img src="image-6.png" alt="Alt text"></p>
<blockquote>
<p>默写答案版本</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">string</span> tmpStr;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch : s)  
        {
            <span class="hljs-keyword">if</span>(!tmpStr.empty() &amp;&amp; (ch == tmpStr.back()))  <span class="hljs-comment">//tmpStr.back()取string的栈顶元素！ </span>
            {
                tmpStr.pop_back();
            }
            <span class="hljs-keyword">else</span>
            {
                tmpStr.push_back(ch);
            }            
        }
        <span class="hljs-keyword">return</span> tmpStr;
    }
};
</div></code></pre>
<h2 id="alt-text"><img src="image-7.png" alt="Alt text"></h2>
<h3 id="5%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC20230726150%E9%A2%98%E4%B8%AD%E7%AD%89">5、逆波兰表达式求值（20230726，150题，中等）</h3>
<p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。</p>
<p>注意：</p>
<ul>
<li>有效的算符为 '+'、'-'、'*' 和 '/' 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 向零截断 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 32 位 整数表示。</li>
</ul>
<p>示例 1：</p>
<ul>
<li>输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]<br>
输出：9<br>
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]<br>
输出：6<br>
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</li>
</ul>

</body>
</html>
